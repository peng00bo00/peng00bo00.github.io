<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> C++ STL笔记05-std::list双向链表 | Bo Peng </title> <meta name="author" content="Bo Peng"> <meta name="description" content="动手实现std::list"> <meta name="keywords" content="Computer Graphics, Geometry Processing"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400..900&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/favicon.png?cc76d8e6f4495e4cf26b99e34f8aefe4"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://peng00bo00.github.io/blog/2023/STL-NOTES-05/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Bo</span> Peng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Post </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Quick Link </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/blog/tag/formatting">Formatting Guide</a> <a class="dropdown-item " href="/blog/category/leetcode">LeetCode</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">C++ STL笔记05-std::list双向链表</h1> <p class="post-meta"> Created in November 18, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/code"> <i class="fa-solid fa-hashtag fa-sm"></i> code</a>   <a href="/blog/tag/c"> <i class="fa-solid fa-hashtag fa-sm"></i> C++</a>   ·   <a href="/blog/category/stl"> <i class="fa-solid fa-tag fa-sm"></i> STL</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="stdlist用法">std::list用法</h2> <p><a href="https://en.cppreference.com/w/cpp/container/list" rel="external nofollow noopener" target="_blank">std::list</a>是C++标准库中的一个容器，它有如下特点：</p> <ul> <li> <p>双向链表结构：<code class="language-plaintext highlighter-rouge">std::list</code>使用双向链表实现，每个元素都包含指向前一个和后一个元素的指针，这使得在列表中间快速插入和删除元素的时间复杂度为<code class="language-plaintext highlighter-rouge">O(1)</code>。</p> </li> <li> <p>非连续内存：与数组不同，<code class="language-plaintext highlighter-rouge">std::list</code>的元素在内存中不是连续存储的，因为每个元素包含指向前后元素的指针。这意味着在插入和删除操作时，不需要移动大量的元素，这有助于提高性能。</p> </li> <li> <p>无随机访问：由于元素不是在连续内存中存储的，因此不能像数组一样通过索引进行<code class="language-plaintext highlighter-rouge">O(1)</code>的随机访问。在 <code class="language-plaintext highlighter-rouge">std::list</code>中，访问元素需要遍历链表，因此时间复杂度为<code class="language-plaintext highlighter-rouge">O(n)</code>。</p> </li> <li> <p>动态大小：<code class="language-plaintext highlighter-rouge">std::list</code>的大小可以动态地增长或减小，不需要提前指定容器的大小。</p> </li> <li> <p>高效的插入和删除操作：由于 <code class="language-plaintext highlighter-rouge">std::list</code>是双向链表，它对于在列表的任意位置执行插入和删除操作非常高效。这使得它在需要频繁插入和删除操作的场景中比较有优势。</p> </li> <li> <p>相对较大的存储开销：由于每个元素都需要额外的指针来指向前一个和后一个元素，相较于数组，<code class="language-plaintext highlighter-rouge">std::list</code>在存储上会有一些额外的开销。</p> </li> <li> <p>不支持随机访问迭代器：<code class="language-plaintext highlighter-rouge">std::list</code>提供双向迭代器，不支持随机访问迭代器。这与支持随机访问的容器(如 <code class="language-plaintext highlighter-rouge">std::vector</code>)不同。</p> </li> </ul> <p><code class="language-plaintext highlighter-rouge">std::list</code>的一些常用用法如下：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
</pre></td> <td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">printList</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 遍历列表并输出元素</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 创建一个存储整数的列表</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myList</span><span class="p">;</span>

    <span class="c1">// 在列表末尾插入元素</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Add to the back: "</span><span class="p">;</span>
    
    <span class="n">myList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">myList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">myList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
    <span class="n">printList</span><span class="p">(</span><span class="n">myList</span><span class="p">);</span>
    
    <span class="c1">// 在列表开头插入元素</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Add to the front: "</span><span class="p">;</span>
    
    <span class="n">myList</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    
    <span class="n">printList</span><span class="p">(</span><span class="n">myList</span><span class="p">);</span>
    
    <span class="c1">// 删除列表末尾的元素</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Remove the last element: "</span><span class="p">;</span>
    
    <span class="n">myList</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    
    <span class="n">printList</span><span class="p">(</span><span class="n">myList</span><span class="p">);</span>
    
    <span class="c1">// 删除列表开头的元素</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Remove the first element: "</span><span class="p">;</span>
    
    <span class="n">myList</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
    
    <span class="n">printList</span><span class="p">(</span><span class="n">myList</span><span class="p">);</span>
    
    <span class="c1">// 在指定位置插入元素</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Insert to the 2nd position: "</span><span class="p">;</span>
    
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">myList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="o">++</span><span class="n">it</span><span class="p">;</span> <span class="c1">// 移动到列表的第二个元素位置</span>
    <span class="n">myList</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    
    <span class="n">printList</span><span class="p">(</span><span class="n">myList</span><span class="p">);</span>

    <span class="c1">// 在指定位置删除元素</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Remove the 2nd element: "</span><span class="p">;</span>
    
    <span class="n">it</span> <span class="o">=</span> <span class="n">myList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="o">++</span><span class="n">it</span><span class="p">;</span> <span class="c1">// 移动到列表的第二个元素位置</span>
    <span class="n">myList</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    
    <span class="n">printList</span><span class="p">(</span><span class="n">myList</span><span class="p">);</span>
    
    <span class="c1">// 获取列表大小</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Size of the list: "</span> <span class="o">&lt;&lt;</span> <span class="n">myList</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// 检查列表是否为空</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">myList</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The list is empty."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The list is not empty."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 清空列表</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Clear the list. "</span> <span class="p">;</span>
    <span class="n">myList</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

    <span class="c1">// 再次检查列表是否为空</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">myList</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The list is empty."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The list is not empty."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>运行上面的代码可以得到如下结果：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> <td class="rouge-code"><pre>Add to the back: 1 2 3 
Add to the front: 0 1 2 3 
Remove the last element: 0 1 2 
Remove the first element: 1 2 
Insert to the 2nd position: 1 4 2 
Remove the 2nd element: 1 2 
Size of the list: 2
The list is not empty.
Clear the list. The list is empty.
</pre></td> </tr></tbody></table></code></pre></div></div> <h2 id="list实现">List实现</h2> <p>接下来我们从零开始实现一个类似于标准库中<code class="language-plaintext highlighter-rouge">std::list</code>的双向链表<code class="language-plaintext highlighter-rouge">List</code>。</p> <h3 id="链表节点">链表节点</h3> <p>在开始实现<code class="language-plaintext highlighter-rouge">List</code>之前我们需要先实现一下链表的节点，它通过<code class="language-plaintext highlighter-rouge">ListBaseNode</code>模板来实现：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> <td class="rouge-code"><pre><span class="cp">#ifdef NDEBUG
#define DEBUG_INIT_DEADBEAF(T)
#else
#define DEBUG_INIT_DEADBEAF(T) {(T *)0xdeadbeaf}
#endif
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ListBaseNode</span> <span class="p">{</span>
    <span class="n">ListBaseNode</span> <span class="o">*</span><span class="n">m_next</span> <span class="n">DEBUG_INIT_DEADBEAF</span><span class="p">(</span><span class="n">ListBaseNode</span><span class="p">);</span>
    <span class="n">ListBaseNode</span> <span class="o">*</span><span class="n">m_prev</span> <span class="n">DEBUG_INIT_DEADBEAF</span><span class="p">(</span><span class="n">ListBaseNode</span><span class="p">);</span>

    <span class="kr">inline</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">();</span>
    <span class="kr">inline</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">ListBaseNode</code>内部包含<code class="language-plaintext highlighter-rouge">m_next</code>以及<code class="language-plaintext highlighter-rouge">m_prev</code>两个指针，分别指向当前节点的前一个和后一个节点。这里引入了一个调试宏<code class="language-plaintext highlighter-rouge">DEBUG_INIT_DEADBEAF</code>：如果<code class="language-plaintext highlighter-rouge">NDEBUG</code>未被定义(即处于调试模式)，<code class="language-plaintext highlighter-rouge">DEBUG_INIT_DEADBEAF</code>会把指针成员初始化为一个特殊的值<code class="language-plaintext highlighter-rouge">0xdeadbeaf</code>以便发现和追踪可能出现的问题。</p> <p>还需要注意的是这里定义的<code class="language-plaintext highlighter-rouge">ListBaseNode</code>本身是不包含任何数据的，我们通过一个继承自<code class="language-plaintext highlighter-rouge">ListBaseNode</code>的新类<code class="language-plaintext highlighter-rouge">ListValueNode</code>来表示一个携带数据的链表节点：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ListValueNode</span> <span class="o">:</span> <span class="n">ListBaseNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">m_value</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">ListBaseNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ListValueNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">m_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">ListBaseNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ListValueNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">m_value</span><span class="p">;</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>当我们需要获取节点的数据时可以通过<code class="language-plaintext highlighter-rouge">value()</code>函数访问实际值所存储的<code class="language-plaintext highlighter-rouge">ListValueNode</code>类。此时函数会先把当前的<code class="language-plaintext highlighter-rouge">ListBaseNode&lt;T&gt;</code>转换为<code class="language-plaintext highlighter-rouge">ListValueNode&lt;T&gt;</code>类型的指针，然后访问<code class="language-plaintext highlighter-rouge">m_value</code>成员变量并返回所需的数据。</p> <h3 id="模板定义">模板定义</h3> <p><code class="language-plaintext highlighter-rouge">List</code>的模板定义类似于<a href="/2023/11/12/STL-NOTES-04.html#%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89">Vector</a>，都包含模板参数<code class="language-plaintext highlighter-rouge">T</code>和<code class="language-plaintext highlighter-rouge">Alloc</code>分别用来指定元素类型和管理内存。<code class="language-plaintext highlighter-rouge">List</code>本身则包含三个成员变量：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">m_dummy</code>为链表的虚拟头节点</li> <li> <code class="language-plaintext highlighter-rouge">m_size</code>用来记录链表的大小</li> <li> <code class="language-plaintext highlighter-rouge">m_alloc</code>用来保存内存分配器</li> </ul> <p>同时，这里还引入了两个类型别名<code class="language-plaintext highlighter-rouge">ListNode</code>和<code class="language-plaintext highlighter-rouge">AllocNode</code>。其中<code class="language-plaintext highlighter-rouge">AllocNode</code>将原本<code class="language-plaintext highlighter-rouge">T</code>类型的内存分配器重新绑定为<code class="language-plaintext highlighter-rouge">ListValueNode&lt;T&gt;</code>类型的内存分配器，这可以方便我们处理节点。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">using</span> <span class="n">ListNode</span>  <span class="o">=</span> <span class="n">ListBaseNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">AllocNode</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Alloc</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">rebind_alloc</span><span class="o">&lt;</span><span class="n">ListValueNode</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">ListNode</span> <span class="n">m_dummy</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">no_unique_address</span><span class="p">]]</span> <span class="n">Alloc</span> <span class="n">m_alloc</span><span class="p">;</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>同时，我们还需要引入一些类型别名作为<code class="language-plaintext highlighter-rouge">List</code>的元信息：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span>      <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">allocator_type</span>  <span class="o">=</span> <span class="n">Alloc</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">size_type</span>       <span class="o">=</span> <span class="kt">size_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="kt">ptrdiff_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">pointer</span>         <span class="o">=</span>  <span class="n">T</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_pointer</span>   <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span>       <span class="o">=</span> <span class="n">T</span> <span class="o">&amp;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_reference</span> <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>为了方便添加和删除节点，这里还定义了两个辅助函数<code class="language-plaintext highlighter-rouge">newNode()</code>和<code class="language-plaintext highlighter-rouge">deleteNode()</code>进行处理：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
<span class="p">...</span>
<span class="nl">private:</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">newNode</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">AllocNode</span><span class="p">{</span><span class="n">m_alloc</span><span class="p">}.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">AllocNode</span><span class="p">{</span><span class="n">m_alloc</span><span class="p">}.</span><span class="n">deallocate</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ListValueNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="构造函数">构造函数</h3> <h4 id="默认构造函数">默认构造函数</h4> <p><code class="language-plaintext highlighter-rouge">List</code>的默认构造函数用来处理无参数构造的情况。此时整个链表为空，我们需要把<code class="language-plaintext highlighter-rouge">m_size</code>设置为0并让虚拟头节点<code class="language-plaintext highlighter-rouge">m_dummy</code>的前后指针都指向自身。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="n">List</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="nf">List</span><span class="p">(</span><span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="参数化构造函数">参数化构造函数</h4> <p>另一种常见情况是初始化一个大小为<code class="language-plaintext highlighter-rouge">n</code>、每个节点包含数据<code class="language-plaintext highlighter-rouge">val</code>的链表。为此我们先来实现一个辅助函数<code class="language-plaintext highlighter-rouge">_uninit_assign()</code>：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="kt">void</span> <span class="n">_uninit_assign</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="o">--</span><span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">_uninit_assign</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(),</span> <span class="n">val</span><span class="p">);</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="o">--</span><span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>此外，我们再实现一个针对迭代器作为输入参数的版本：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(),</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
            <span class="o">++</span><span class="n">m_size</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>完成辅助函数<code class="language-plaintext highlighter-rouge">_uninit_assign()</code>后，我们就可以在参数构造函数中把参数转发给<code class="language-plaintext highlighter-rouge">_uninit_assign()</code>进行初始化：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">List</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">List</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="n">List</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">List</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span>
    <span class="o">:</span> <span class="n">List</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">alloc</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="移动构造函数">移动构造函数</h4> <p>对于移动构造的情况，我们同样需要先实现一个辅助函数<code class="language-plaintext highlighter-rouge">_uninit_move_assign()</code>：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="kt">void</span> <span class="n">_uninit_move_assign</span><span class="p">(</span><span class="n">List</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="p">;</span>

        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
        <span class="n">next</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="n">m_dummy</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>这样就可以在移动构造中将参数转发给<code class="language-plaintext highlighter-rouge">_uninit_move_assign()</code>完成初始化：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="n">List</span><span class="p">(</span><span class="n">List</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">_uninit_move_assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">List</span><span class="p">(</span><span class="n">List</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_uninit_move_assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">List</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">List</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">);</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="n">_uninit_move_assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">));</span>

        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="拷贝构造函数">拷贝构造函数</h4> <p><code class="language-plaintext highlighter-rouge">List</code>的拷贝构造函数比较简单，我们可以直接调用前面实现的<code class="language-plaintext highlighter-rouge">_uninit_assign()</code>：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="n">List</span><span class="p">(</span><span class="n">List</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">cend</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">List</span><span class="p">(</span><span class="n">List</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">cend</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">List</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">List</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assign</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">cend</span><span class="p">());</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">List</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assign</span><span class="p">(</span><span class="n">ilist</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>实际上这里定义的拷贝构造函数是通过<a href="/2023/11/18/STL-NOTES-05.html#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>以及<a href="/2023/11/18/STL-NOTES-05.html#assign">assign()</a>函数来实现的。关于<a href="/2023/11/18/STL-NOTES-05.html#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>和<a href="/2023/11/18/STL-NOTES-05.html#assign">assign()</a>函数相关的代码我们会稍后再介绍。</p> <h3 id="访问元素">访问元素</h3> <p><code class="language-plaintext highlighter-rouge">List</code>不允许随机访问，我们只能通过对链表进行遍历的方式来访问其中的元素。这里只需要实现访问链表首尾节点的相关函数即可：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="迭代器">迭代器</h3> <p><code class="language-plaintext highlighter-rouge">List</code>需要实现双向迭代器，为此我们在<code class="language-plaintext highlighter-rouge">List</code>内部定义一个<code class="language-plaintext highlighter-rouge">iterator</code>类：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="k">struct</span> <span class="nc">iterator</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bidirectional_iterator_tag</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">value_type</span>        <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">difference_type</span>   <span class="o">=</span> <span class="kt">ptrdiff_t</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">pointer</span>           <span class="o">=</span> <span class="n">T</span> <span class="o">*</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">reference</span>         <span class="o">=</span> <span class="n">T</span> <span class="o">&amp;</span><span class="p">;</span>

    <span class="nl">private:</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">m_curr</span><span class="p">;</span>

        <span class="k">friend</span> <span class="n">List</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="n">iterator</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">m_curr</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>对于双向迭代器，<code class="language-plaintext highlighter-rouge">iterator</code>需要实现前缀递增<code class="language-plaintext highlighter-rouge">++iterator</code>、后缀递增<code class="language-plaintext highlighter-rouge">iterator++</code>、前缀递减<code class="language-plaintext highlighter-rouge">--iterator</code>、后缀递减<code class="language-plaintext highlighter-rouge">iterator--</code>、解引用<code class="language-plaintext highlighter-rouge">*</code>、以及比较<code class="language-plaintext highlighter-rouge">==</code><code class="language-plaintext highlighter-rouge">!=</code>等操作：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="k">struct</span> <span class="nc">iterator</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="nl">public:</span>
        <span class="n">iterator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="n">iterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// ++iterator</span>
            <span class="n">m_curr</span> <span class="o">=</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// iterator++</span>
            <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">iterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">--</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// --iterator</span>
            <span class="n">m_curr</span> <span class="o">=</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">m_prev</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">iterator</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// iterator--</span>
            <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">iterator</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_curr</span> <span class="o">!=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_curr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">iterator</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">!=</span> <span class="n">that</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>有了<code class="language-plaintext highlighter-rouge">iterator</code>的实现后就可以实现<code class="language-plaintext highlighter-rouge">List</code>的迭代器行为：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">iterator</span><span class="p">{</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">iterator</span><span class="p">{</span><span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="k">using</span> <span class="n">reverse_iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">reverse_iterator</span> <span class="nf">rbegin</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">reverse_iterator</span> <span class="nf">rend</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">begin</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>类似地，我们还可以实现常量迭代器<code class="language-plaintext highlighter-rouge">const_iterator</code>处理常量迭代的情况：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="k">struct</span> <span class="nc">const_iterator</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bidirectional_iterator_tag</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">value_type</span>        <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">difference_type</span>   <span class="o">=</span> <span class="kt">ptrdiff_t</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">pointer</span>           <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">reference</span>         <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span>

    <span class="nl">private:</span>
        <span class="n">ListNode</span> <span class="k">const</span> <span class="o">*</span><span class="n">m_curr</span><span class="p">;</span>

        <span class="k">friend</span> <span class="n">List</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="n">const_iterator</span><span class="p">(</span><span class="n">ListNode</span> <span class="k">const</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">m_curr</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">const_iterator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="n">const_iterator</span><span class="p">(</span><span class="n">iterator</span> <span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">m_curr</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_curr</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span>

        <span class="k">explicit</span> <span class="k">operator</span> <span class="n">iterator</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">iterator</span><span class="p">{</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">ListNode</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">m_curr</span><span class="p">)};</span>
        <span class="p">}</span>

        <span class="n">const_iterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// ++iterator</span>
            <span class="n">m_curr</span> <span class="o">=</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">const_iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// iterator++</span>
            <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">const_iterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">--</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// --iterator</span>
            <span class="n">m_curr</span> <span class="o">=</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">m_prev</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">const_iterator</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// iterator--</span>
            <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">const_iterator</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_curr</span> <span class="o">!=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_curr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">const_iterator</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">!=</span> <span class="n">that</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">const_iterator</span><span class="p">{</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">const_iterator</span><span class="p">{</span><span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="n">const_iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">cbegin</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">const_iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">cend</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">using</span> <span class="n">reverse_const_iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">reverse_const_iterator</span> <span class="nf">crbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">cend</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">reverse_const_iterator</span> <span class="nf">crend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">cbegin</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">reverse_const_iterator</span> <span class="nf">rbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">crbegin</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">reverse_const_iterator</span> <span class="nf">rend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">crend</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="修改链表">修改链表</h3> <h4 id="clear">clear()</h4> <p><code class="language-plaintext highlighter-rouge">clear()</code>函数的作用是清空当前链表。在调用时<code class="language-plaintext highlighter-rouge">clear()</code>函数会依次访问链表的每个节点，然后清除节点数据并释放节点自身的内存：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
            <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>
            <span class="n">deleteNode</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">List</code>的析构函数就是基于<code class="language-plaintext highlighter-rouge">clear()</code>函数实现的：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="o">~</span><span class="n">List</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="assign">assign()</h4> <p><code class="language-plaintext highlighter-rouge">assign()</code>函数的作用类似于参数化构造函数中的<code class="language-plaintext highlighter-rouge">_uninit_assign()</code>。实际上<code class="language-plaintext highlighter-rouge">assign()</code>函数也是基于<code class="language-plaintext highlighter-rouge">_uninit_assign()</code>来实现的，不过要在调用<code class="language-plaintext highlighter-rouge">_uninit_assign()</code>前先清空链表：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">assign</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="emplace_back和emplace_front">emplace_back()和emplace_front()</h4> <p><code class="language-plaintext highlighter-rouge">emplace_back()</code>函数的作用是构造一个新的链表节点并将它插入到链表的末尾。类似于<code class="language-plaintext highlighter-rouge">Vector</code>中的<a href="/2023/11/12/STL-NOTES-04.html#emplace_back">实现</a>，这里同样使用了变长参数模板：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span><span class="p">;</span>

        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

        <span class="o">++</span><span class="n">m_size</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">emplace_front()</code>函数的实现与<code class="language-plaintext highlighter-rouge">emplace_back()</code>基本一致，唯一的区别在于它会把新构造的节点插入到链表头：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="n">emplace_front</span><span class="p">(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="p">;</span>

        <span class="n">next</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

        <span class="o">++</span><span class="n">m_size</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="push_back和push_front">push_back()和push_front()</h4> <p>在<code class="language-plaintext highlighter-rouge">emplace_back()</code>和<code class="language-plaintext highlighter-rouge">emplace_front()</code>的基础上就可以很容易地实现<code class="language-plaintext highlighter-rouge">push_back()</code>和<code class="language-plaintext highlighter-rouge">push_front()</code>两个函数：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">emplace_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">push_front</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">emplace_front</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">push_front</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// don't repeat yourself (DRY)</span>
        <span class="n">emplace_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="erase">erase()</h4> <p><code class="language-plaintext highlighter-rouge">erase()</code>函数的作用是根据迭代器<code class="language-plaintext highlighter-rouge">pos</code>的位置清除指定的节点：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="n">iterator</span> <span class="n">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">ListNode</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">m_curr</span><span class="p">);</span>

        <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span><span class="p">;</span>

        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">next</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
        <span class="n">deleteNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

        <span class="o">--</span><span class="n">m_size</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">iterator</span><span class="p">{</span><span class="n">next</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>除此之外，我们再实现一个针对迭代范围的版本，它会清除指定范围内的所有节点：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="n">iterator</span> <span class="n">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">erase</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nf">iterator</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="pop_front和pop_back">pop_front()和pop_back()</h4> <p>在<code class="language-plaintext highlighter-rouge">erase()</code>函数的基础上我们只需要把<code class="language-plaintext highlighter-rouge">begin()</code>和<code class="language-plaintext highlighter-rouge">end()</code>作为输入参数就可以实现<code class="language-plaintext highlighter-rouge">pop_front()</code>和<code class="language-plaintext highlighter-rouge">pop_back()</code>：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">pop_front</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">erase</span><span class="p">(</span><span class="n">begin</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">pop_back</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">prev</span><span class="p">(</span><span class="n">end</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="remove">remove()</h4> <p><code class="language-plaintext highlighter-rouge">remove()</code>函数的作用类似于<code class="language-plaintext highlighter-rouge">erase()</code>，不过它是根据值<code class="language-plaintext highlighter-rouge">val</code>来判断是否需要删除节点。<code class="language-plaintext highlighter-rouge">remove()</code>函数会删除链表中所有值为<code class="language-plaintext highlighter-rouge">val</code>的节点：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="kt">size_t</span> <span class="n">remove</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">begin</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">last</span> <span class="o">=</span> <span class="n">begin</span><span class="p">();</span>

        <span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">first</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">erase</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
                <span class="o">++</span><span class="n">count</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="o">++</span><span class="n">first</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>与之类似的还有<code class="language-plaintext highlighter-rouge">remove_if()</code>，它接收一个函数对象<code class="language-plaintext highlighter-rouge">pred</code>作为参数。当<code class="language-plaintext highlighter-rouge">pred</code>在某个节点处进行调用并返回<code class="language-plaintext highlighter-rouge">true</code>时，<code class="language-plaintext highlighter-rouge">remove_if()</code>会将该节点删除：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Pred</span><span class="p">&gt;</span>
    <span class="kt">size_t</span> <span class="n">remove_if</span><span class="p">(</span><span class="n">Pred</span> <span class="o">&amp;&amp;</span><span class="n">pred</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">begin</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">last</span> <span class="o">=</span> <span class="n">begin</span><span class="p">();</span>

        <span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">erase</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
                <span class="o">++</span><span class="n">count</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="o">++</span><span class="n">first</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="emplace">emplace()</h4> <p><code class="language-plaintext highlighter-rouge">emplace()</code>函数有着和<code class="language-plaintext highlighter-rouge">erase()</code>相反的作用，它可以在迭代器<code class="language-plaintext highlighter-rouge">pos</code>位置创建一个新的节点。类似于<code class="language-plaintext highlighter-rouge">emplace_back()</code>和<code class="language-plaintext highlighter-rouge">emplace_front()</code>，<code class="language-plaintext highlighter-rouge">emplace()</code>同样使用了变长参数模板来实现：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
    <span class="n">iterator</span> <span class="n">emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>

        <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">ListNode</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">m_curr</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">m_prev</span><span class="p">;</span>

        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">next</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>

        <span class="o">++</span><span class="n">m_size</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">iterator</span><span class="p">{</span><span class="n">curr</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="insert">insert()</h4> <p>在<code class="language-plaintext highlighter-rouge">emplace()</code>函数的基础上我们可以实现<code class="language-plaintext highlighter-rouge">insert()</code>函数，它用来将值<code class="language-plaintext highlighter-rouge">val</code>插入到<code class="language-plaintext highlighter-rouge">pos</code>位置上：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="n">iterator</span> <span class="n">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">emplace</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">emplace</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">orig</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">had_orig</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">emplace</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">had_orig</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">had_orig</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">orig</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="o">++</span><span class="n">pos</span><span class="p">;</span>
            <span class="o">--</span><span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nf">iterator</span><span class="p">(</span><span class="n">orig</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>除了上面三种标准用法外，我们还可以针对迭代器输入进行单独处理：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="n">iterator</span> <span class="n">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">orig</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">had_orig</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">emplace</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">had_orig</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">had_orig</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">orig</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="o">++</span><span class="n">pos</span><span class="p">;</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">iterator</span><span class="p">(</span><span class="n">orig</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="splice">splice()</h4> <p><code class="language-plaintext highlighter-rouge">splice()</code>函数可以把另一个<code class="language-plaintext highlighter-rouge">List</code>插入到指定位置上：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">splice</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">List</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">begin</span><span class="p">()),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="其它函数">其它函数</h3> <p><code class="language-plaintext highlighter-rouge">List</code>中有一些获取链表信息的函数，这里简单汇总一下：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">max_size</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">Alloc</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_alloc</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>不同<code class="language-plaintext highlighter-rouge">List</code>对象之间的比较我们则可以利用标准库的相关函数来实现：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">List</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">equal</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="n">List</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">lexicographical_compare_three_way</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="完整实现">完整实现</h3> <p>总结一下，整个<code class="language-plaintext highlighter-rouge">List</code>的代码可以参考如下：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
</pre></td> <td class="rouge-code"><pre><span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;compare&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;initializer_list&gt;</span><span class="cp">
</span>
<span class="cp">#ifdef NDEBUG
#define DEBUG_INIT_DEADBEAF(T)
#else
#define DEBUG_INIT_DEADBEAF(T) {(T *)0xdeadbeaf}
#endif
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ListBaseNode</span> <span class="p">{</span>
    <span class="n">ListBaseNode</span> <span class="o">*</span><span class="n">m_next</span> <span class="n">DEBUG_INIT_DEADBEAF</span><span class="p">(</span><span class="n">ListBaseNode</span><span class="p">);</span>
    <span class="n">ListBaseNode</span> <span class="o">*</span><span class="n">m_prev</span> <span class="n">DEBUG_INIT_DEADBEAF</span><span class="p">(</span><span class="n">ListBaseNode</span><span class="p">);</span>

    <span class="kr">inline</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">();</span>
    <span class="kr">inline</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ListValueNode</span> <span class="o">:</span> <span class="n">ListBaseNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">m_value</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">ListBaseNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ListValueNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">m_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">ListBaseNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ListValueNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">m_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span>        <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">allocator_type</span>    <span class="o">=</span> <span class="n">Alloc</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">size_type</span>         <span class="o">=</span> <span class="kt">size_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">difference_type</span>   <span class="o">=</span> <span class="kt">ptrdiff_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">pointer</span>           <span class="o">=</span> <span class="n">T</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_pointer</span>     <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span>         <span class="o">=</span> <span class="n">T</span> <span class="o">&amp;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_reference</span>   <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="k">using</span> <span class="n">ListNode</span>  <span class="o">=</span> <span class="n">ListBaseNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">AllocNode</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Alloc</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">rebind_alloc</span><span class="o">&lt;</span><span class="n">ListValueNode</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">ListNode</span> <span class="n">m_dummy</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">no_unique_address</span><span class="p">]]</span> <span class="n">Alloc</span> <span class="n">m_alloc</span><span class="p">;</span>

    <span class="n">ListNode</span> <span class="o">*</span><span class="n">newNode</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">AllocNode</span><span class="p">{</span><span class="n">m_alloc</span><span class="p">}.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">AllocNode</span><span class="p">{</span><span class="n">m_alloc</span><span class="p">}.</span><span class="n">deallocate</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ListValueNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">List</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="nf">List</span><span class="p">(</span><span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">List</span><span class="p">(</span><span class="n">List</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">_uninit_move_assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">List</span><span class="p">(</span><span class="n">List</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_uninit_move_assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">List</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">List</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">);</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="n">_uninit_move_assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">));</span>

        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="nf">_uninit_move_assign</span><span class="p">(</span><span class="n">List</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="p">;</span>

        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
        <span class="n">next</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="n">m_dummy</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">.</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">List</span><span class="p">(</span><span class="n">List</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">cend</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">List</span><span class="p">(</span><span class="n">List</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">cend</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">List</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">List</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assign</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">cend</span><span class="p">());</span>

        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">==</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="nf">List</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">List</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="n">List</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">List</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span>
    <span class="o">:</span> <span class="n">List</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">alloc</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">List</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assign</span><span class="p">(</span><span class="n">ilist</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="nf">_uninit_assign</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>

            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>

            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(),</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
            <span class="o">++</span><span class="n">m_size</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">_uninit_assign</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>

            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>

            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(),</span> <span class="n">val</span><span class="p">);</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

            <span class="o">--</span><span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">_uninit_assign</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>

            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>

            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

            <span class="o">--</span><span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">max_size</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="n">_uninit_assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">emplace_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">push_front</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">emplace_front</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">push_front</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// don't repeat yourself (DRY)</span>
        <span class="n">emplace_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span><span class="p">;</span>

        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

        <span class="o">++</span><span class="n">m_size</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="n">emplace_front</span><span class="p">(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="p">;</span>

        <span class="n">next</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

        <span class="o">++</span><span class="n">m_size</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">List</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
            <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>
            <span class="n">deleteNode</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">;</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="nc">iterator</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bidirectional_iterator_tag</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">value_type</span>        <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">difference_type</span>   <span class="o">=</span> <span class="kt">ptrdiff_t</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">pointer</span>           <span class="o">=</span> <span class="n">T</span> <span class="o">*</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">reference</span>         <span class="o">=</span> <span class="n">T</span> <span class="o">&amp;</span><span class="p">;</span>

    <span class="nl">private:</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">m_curr</span><span class="p">;</span>

        <span class="k">friend</span> <span class="n">List</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="n">iterator</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">m_curr</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">iterator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="n">iterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// ++iterator</span>
            <span class="n">m_curr</span> <span class="o">=</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// iterator++</span>
            <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">iterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">--</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// --iterator</span>
            <span class="n">m_curr</span> <span class="o">=</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">m_prev</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">iterator</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// iterator--</span>
            <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">iterator</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_curr</span> <span class="o">!=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_curr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">iterator</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">!=</span> <span class="n">that</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">const_iterator</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bidirectional_iterator_tag</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">value_type</span>        <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">difference_type</span>   <span class="o">=</span> <span class="kt">ptrdiff_t</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">pointer</span>           <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">reference</span>         <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span>

    <span class="nl">private:</span>
        <span class="n">ListNode</span> <span class="k">const</span> <span class="o">*</span><span class="n">m_curr</span><span class="p">;</span>

        <span class="k">friend</span> <span class="n">List</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="n">const_iterator</span><span class="p">(</span><span class="n">ListNode</span> <span class="k">const</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">m_curr</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">const_iterator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="n">const_iterator</span><span class="p">(</span><span class="n">iterator</span> <span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">m_curr</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_curr</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span>

        <span class="k">explicit</span> <span class="k">operator</span> <span class="n">iterator</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">iterator</span><span class="p">{</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">ListNode</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">m_curr</span><span class="p">)};</span>
        <span class="p">}</span>

        <span class="n">const_iterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// ++iterator</span>
            <span class="n">m_curr</span> <span class="o">=</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">const_iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// iterator++</span>
            <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">const_iterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">--</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// --iterator</span>
            <span class="n">m_curr</span> <span class="o">=</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">m_prev</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">const_iterator</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// iterator--</span>
            <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">const_iterator</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_curr</span> <span class="o">!=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_curr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">const_iterator</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">!=</span> <span class="n">that</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">iterator</span><span class="p">{</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">iterator</span><span class="p">{</span><span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">const_iterator</span><span class="p">{</span><span class="n">m_dummy</span><span class="p">.</span><span class="n">m_next</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">const_iterator</span><span class="p">{</span><span class="o">&amp;</span><span class="n">m_dummy</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="n">const_iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">cbegin</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">const_iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">cend</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">using</span> <span class="n">reverse_iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reverse_const_iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">reverse_iterator</span> <span class="nf">rbegin</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">reverse_iterator</span> <span class="nf">rend</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">begin</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">reverse_const_iterator</span> <span class="nf">crbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">cend</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">reverse_const_iterator</span> <span class="nf">crend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">cbegin</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">reverse_const_iterator</span> <span class="nf">rbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">crbegin</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">reverse_const_iterator</span> <span class="nf">rend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">crend</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">ListNode</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">m_curr</span><span class="p">);</span>

        <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_prev</span><span class="p">;</span>

        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">next</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
        <span class="n">deleteNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

        <span class="o">--</span><span class="n">m_size</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">iterator</span><span class="p">{</span><span class="n">next</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">erase</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nf">iterator</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">pop_front</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">erase</span><span class="p">(</span><span class="n">begin</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">pop_back</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">prev</span><span class="p">(</span><span class="n">end</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="kt">size_t</span> <span class="nf">remove</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">begin</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">last</span> <span class="o">=</span> <span class="n">begin</span><span class="p">();</span>

        <span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">first</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">erase</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
                <span class="o">++</span><span class="n">count</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="o">++</span><span class="n">first</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Pred</span><span class="p">&gt;</span>
    <span class="kt">size_t</span> <span class="nf">remove_if</span><span class="p">(</span><span class="n">Pred</span> <span class="o">&amp;&amp;</span><span class="n">pred</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">begin</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">last</span> <span class="o">=</span> <span class="n">begin</span><span class="p">();</span>

        <span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">erase</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
                <span class="o">++</span><span class="n">count</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="o">++</span><span class="n">first</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
    <span class="n">iterator</span> <span class="nf">emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">();</span>

        <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">ListNode</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">m_curr</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">m_prev</span><span class="p">;</span>

        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">m_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">next</span><span class="o">-&gt;</span><span class="n">m_prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>

        <span class="o">++</span><span class="n">m_size</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">iterator</span><span class="p">{</span><span class="n">curr</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">emplace</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">emplace</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">orig</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">had_orig</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">emplace</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">had_orig</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">had_orig</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">orig</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="o">++</span><span class="n">pos</span><span class="p">;</span>
            <span class="o">--</span><span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nf">iterator</span><span class="p">(</span><span class="n">orig</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">orig</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">had_orig</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">emplace</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">had_orig</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">had_orig</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">orig</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="o">++</span><span class="n">pos</span><span class="p">;</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nf">iterator</span><span class="p">(</span><span class="n">orig</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">splice</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">List</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">begin</span><span class="p">()),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="n">Alloc</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_alloc</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">List</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">equal</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="n">List</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">lexicographical_compare_three_way</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h2 id="reference">Reference</h2> <ul> <li><a href="https://github.com/parallel101/stl1weekend/tree/main#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89stl%E5%AE%B9%E5%99%A8" rel="external nofollow noopener" target="_blank">stl1weekend</a></li> <li><a href="https://www.bilibili.com/video/BV1SC4y1G7Ab/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">【C++模板封装教学】自己动手实现循环双链表std::list，支持增删改查，迭代器双向遍历</a></li> </ul> </div> </article> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Bo Peng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-post",title:"Post",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"A growing collection of my projects.",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-cv",title:"CV",description:"\u4e2a\u4eba\u7b80\u5386",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"dropdown-formatting-guide",title:"Formatting Guide",description:"",section:"Dropdown",handler:()=>{window.location.href="/blog/"}},{id:"dropdown-leetcode",title:"LeetCode",description:"",section:"Dropdown",handler:()=>{window.location.href="/blog/"}},{id:"post-lbm\u6d41\u4f53\u4eff\u771f",title:"LBM\u6d41\u4f53\u4eff\u771f",description:"\u57fa\u4e8eLBM\u65b9\u6cd5\u5b9e\u73b0\u4e8c\u7ef4\u6d41\u4f53\u4eff\u771f",section:"Posts",handler:()=>{window.location.href="/blog/2025/LBM/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb014-\u6df1\u5ea6\u5b66\u4e60",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb014-\u6df1\u5ea6\u5b66\u4e60",description:"\u751f\u6210\u5f0f\u6a21\u578b\u80cc\u540e\u7684\u6570\u5b66\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-14/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb013-\u4f18\u5316\u57fa\u7840",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb013-\u4f18\u5316\u57fa\u7840",description:"\u56fe\u5f62\u5b66\u4e2d\u5e38\u7528\u7684\u4f18\u5316\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-13/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb012-\u7ebf\u6027\u7cfb\u7edf",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb012-\u7ebf\u6027\u7cfb\u7edf",description:"\u6c42\u89e3\u7ebf\u6027\u7cfb\u7edf\u7684\u76f8\u5173\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-12/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb007-\u6d3b\u52a8\u6807\u67b6\u548c\u5916\u5fae\u5206\u6cd5",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb007-\u6d3b\u52a8\u6807\u67b6\u548c\u5916\u5fae\u5206\u6cd5",description:"\u5fae\u5206\u51e0\u4f55\u4e2d\u7684\u5916\u5fae\u5206\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2024/DifferentialGeometry-NOTES-07/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb011-\u5fae\u5206\u65b9\u7a0b",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb011-\u5fae\u5206\u65b9\u7a0b",description:"\u5fae\u5206\u65b9\u7a0b\u7684\u6c42\u89e3\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-11/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb010-\u53e4\u5178\u5fae\u5206\u51e0\u4f55",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb010-\u53e4\u5178\u5fae\u5206\u51e0\u4f55",description:"\u53e4\u5178\u5fae\u5206\u51e0\u4f55\u7684\u57fa\u672c\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-10/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb009-\u573a\u8bba\u521d\u6b65",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb009-\u573a\u8bba\u521d\u6b65",description:"\u573a\u8bba\u7684\u57fa\u672c\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-09/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb008-\u6982\u7387\u8bbaii",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb008-\u6982\u7387\u8bbaII",description:"\u6982\u7387\u8bba\u5728\u56fe\u5f62\u5b66\u4e2d\u7684\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-08/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb006-\u6d4b\u5730\u66f2\u7387\u548c\u6d4b\u5730\u7ebf",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb006-\u6d4b\u5730\u66f2\u7387\u548c\u6d4b\u5730\u7ebf",description:"\u66f2\u9762\u7684\u5185\u8574\u51e0\u4f55",section:"Posts",handler:()=>{window.location.href="/blog/2024/DifferentialGeometry-NOTES-06/"}},{id:"post-a-post-with-tabs",title:"a post with tabs",description:"this is what included tabs in a post could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/tabs/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb007-\u6982\u7387\u8bbai",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb007-\u6982\u7387\u8bbaI",description:"\u6982\u7387\u8bba\u57fa\u7840\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-07/"}},{id:"post-a-post-with-typograms",title:"a post with typograms",description:"this is what included typograms code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/typograms/"}},{id:"post-a-post-that-can-be-cited",title:"a post that can be cited",description:"this is what a post that can be cited looks like",section:"Posts",handler:()=>{window.location.href="/blog/2024/post-citation/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb006-\u5085\u91cc\u53f6\u53d8\u6362\u4e0e\u7403\u8c10\u51fd\u6570",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb006-\u5085\u91cc\u53f6\u53d8\u6362\u4e0e\u7403\u8c10\u51fd\u6570",description:"\u8c31\u53d8\u6362\u4e0e\u7403\u8c10\u51fd\u6570\u76f8\u5173\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-06/"}},{id:"post-a-post-with-pseudo-code",title:"a post with pseudo code",description:"this is what included pseudo code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/pseudocode/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb005-\u63d2\u503c-amp-\u62df\u5408",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb005-\u63d2\u503c&\u62df\u5408",description:"\u51fd\u6570\u63d2\u503c\u4e0e\u62df\u5408\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-05/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb004-\u5947\u5f02\u503c\u5206\u89e3\u4e0e\u4e3b\u6210\u5206\u5206\u6790",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb004-\u5947\u5f02\u503c\u5206\u89e3\u4e0e\u4e3b\u6210\u5206\u5206\u6790",description:"SVD\u4e0ePCA\u80cc\u540e\u7684\u6570\u5b66",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-04/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb003-\u65cb\u8f6c\u53d8\u6362",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb003-\u65cb\u8f6c\u53d8\u6362",description:"\u4e09\u7ef4\u65cb\u8f6c\u80cc\u540e\u7684\u6570\u5b66\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-03/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb002-\u8ba1\u7b97\u51e0\u4f55",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb002-\u8ba1\u7b97\u51e0\u4f55",description:"\u8ba1\u7b97\u51e0\u4f55\u76f8\u5173\u5185\u5bb9",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-02/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb001-\u7ebf\u6027\u4ee3\u6570\u57fa\u7840",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb001-\u7ebf\u6027\u4ee3\u6570\u57fa\u7840",description:"\u7ebf\u6027\u4ee3\u6570\u57fa\u7840\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-01/"}},{id:"post-a-post-with-code-diff",title:"a post with code diff",description:"this is how you can display code diffs",section:"Posts",handler:()=>{window.location.href="/blog/2024/code-diff/"}},{id:"post-a-post-with-advanced-image-components",title:"a post with advanced image components",description:"this is what advanced image components could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/advanced-images/"}},{id:"post-a-post-with-vega-lite",title:"a post with vega lite",description:"this is what included vega lite code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/vega-lite/"}},{id:"post-a-post-with-geojson",title:"a post with geojson",description:"this is what included geojson code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/geojson-map/"}},{id:"post-a-post-with-echarts",title:"a post with echarts",description:"this is what included echarts code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/echarts/"}},{id:"post-a-post-with-chart-js",title:"a post with chart.js",description:"this is what included chart.js code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/chartjs/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb005-\u66f2\u9762\u8bba\u57fa\u672c\u5b9a\u7406",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb005-\u66f2\u9762\u8bba\u57fa\u672c\u5b9a\u7406",description:"\u66f2\u9762\u8bba\u57fa\u672c\u5b9a\u7406",section:"Posts",handler:()=>{window.location.href="/blog/2023/DifferentialGeometry-NOTES-05/"}},{id:"post-a-post-with-tikzjax",title:"a post with TikZJax",description:"this is what included TikZ code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2023/tikzjax/"}},{id:"post-c-stl\u7b14\u8bb005-std-list\u53cc\u5411\u94fe\u8868",title:"C++ STL\u7b14\u8bb005-std::list\u53cc\u5411\u94fe\u8868",description:"\u52a8\u624b\u5b9e\u73b0std::list",section:"Posts",handler:()=>{window.location.href="/blog/2023/STL-NOTES-05/"}},{id:"post-c-stl\u7b14\u8bb004-std-vector\u52a8\u6001\u6570\u7ec4",title:"C++ STL\u7b14\u8bb004-std::vector\u52a8\u6001\u6570\u7ec4",description:"\u52a8\u624b\u5b9e\u73b0std::vector",section:"Posts",handler:()=>{window.location.href="/blog/2023/STL-NOTES-04/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb004-\u66f2\u9762\u7684\u7b2c\u4e8c\u57fa\u672c\u5f62\u5f0f",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb004-\u66f2\u9762\u7684\u7b2c\u4e8c\u57fa\u672c\u5f62\u5f0f",description:"\u66f2\u9762\u7684\u7b2c\u4e8c\u57fa\u672c\u5f62\u5f0f",section:"Posts",handler:()=>{window.location.href="/blog/2023/DifferentialGeometry-NOTES-04/"}},{id:"post-c-stl\u7b14\u8bb003-std-array\u6570\u7ec4",title:"C++ STL\u7b14\u8bb003-std::array\u6570\u7ec4",description:"\u52a8\u624b\u5b9e\u73b0std::array",section:"Posts",handler:()=>{window.location.href="/blog/2023/STL-NOTES-03/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb003-\u66f2\u9762\u7684\u7b2c\u4e00\u57fa\u672c\u5f62\u5f0f",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb003-\u66f2\u9762\u7684\u7b2c\u4e00\u57fa\u672c\u5f62\u5f0f",description:"\u66f2\u9762\u7684\u7b2c\u4e00\u57fa\u672c\u5f62\u5f0f",section:"Posts",handler:()=>{window.location.href="/blog/2023/DifferentialGeometry-NOTES-03/"}},{id:"post-c-stl\u7b14\u8bb002-std-unique-ptr\u72ec\u5360\u578b\u667a\u80fd\u6307\u9488",title:"C++ STL\u7b14\u8bb002-std::unique_ptr\u72ec\u5360\u578b\u667a\u80fd\u6307\u9488",description:"\u52a8\u624b\u5b9e\u73b0std::unique_ptr",section:"Posts",handler:()=>{window.location.href="/blog/2023/STL-NOTES-02/"}},{id:"post-c-stl\u7b14\u8bb001-std-function\u5bb9\u5668",title:"C++ STL\u7b14\u8bb001-std::function\u5bb9\u5668",description:"\u52a8\u624b\u5b9e\u73b0std::function",section:"Posts",handler:()=>{window.location.href="/blog/2023/STL-NOTES-01/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb002-\u66f2\u7ebf\u8bba",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb002-\u66f2\u7ebf\u8bba",description:"\u66f2\u7ebf\u8bba\u76f8\u5173\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2023/DifferentialGeometry-NOTES-02/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb001-\u9884\u5907\u77e5\u8bc6",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb001-\u9884\u5907\u77e5\u8bc6",description:"\u5fae\u5206\u51e0\u4f55\u9884\u5907\u77e5\u8bc6\u4e0e\u5e38\u7528\u7ed3\u8bba",section:"Posts",handler:()=>{window.location.href="/blog/2023/DifferentialGeometry-NOTES-01/"}},{id:"post-a-post-with-bibliography",title:"a post with bibliography",description:"an example of a blog post with bibliography",section:"Posts",handler:()=>{window.location.href="/blog/2023/post-bibliography/"}},{id:"post-a-post-with-jupyter-notebook",title:"a post with jupyter notebook",description:"an example of a blog post with jupyter notebook",section:"Posts",handler:()=>{window.location.href="/blog/2023/jupyter-notebook/"}},{id:"post-a-post-with-custom-blockquotes",title:"a post with custom blockquotes",description:"an example of a blog post with custom blockquotes",section:"Posts",handler:()=>{window.location.href="/blog/2023/custom-blockquotes/"}},{id:"post-a-post-with-table-of-contents-on-a-sidebar",title:"a post with table of contents on a sidebar",description:"an example of a blog post with table of contents on a sidebar",section:"Posts",handler:()=>{window.location.href="/blog/2023/sidebar-table-of-contents/"}},{id:"post-a-post-with-audios",title:"a post with audios",description:"this is what included audios could look like",section:"Posts",handler:()=>{window.location.href="/blog/2023/audios/"}},{id:"post-a-post-with-videos",title:"a post with videos",description:"this is what included videos could look like",section:"Posts",handler:()=>{window.location.href="/blog/2023/videos/"}},{id:"post-\u5e76\u67e5\u96c6",title:"\u5e76\u67e5\u96c6",description:"LeetCode\u5e76\u67e5\u96c6\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/UnionFindSet/"}},{id:"post-\u56fe\u8bba",title:"\u56fe\u8bba",description:"LeetCode\u56fe\u8bba\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/Graph/"}},{id:"post-\u5355\u8c03\u6808",title:"\u5355\u8c03\u6808",description:"LeetCode\u5355\u8c03\u6808\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/MonotoneStack/"}},{id:"post-displaying-beautiful-tables-with-bootstrap-tables",title:"displaying beautiful tables with Bootstrap Tables",description:"an example of how to use Bootstrap Tables",section:"Posts",handler:()=>{window.location.href="/blog/2023/tables/"}},{id:"post-a-post-with-table-of-contents",title:"a post with table of contents",description:"an example of a blog post with table of contents",section:"Posts",handler:()=>{window.location.href="/blog/2023/table-of-contents/"}},{id:"post-\u52a8\u6001\u89c4\u5212",title:"\u52a8\u6001\u89c4\u5212",description:"LeetCode\u52a8\u6001\u89c4\u5212\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/DynamicProgramming/"}},{id:"post-\u8d2a\u5fc3",title:"\u8d2a\u5fc3",description:"LeetCode\u8d2a\u5fc3\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/Greedy/"}},{id:"post-\u56de\u6eaf",title:"\u56de\u6eaf",description:"LeetCode\u56de\u6eaf\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/Backtracking/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb021-consistent-correspondence",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb021-Consistent Correspondence",description:"\u66f2\u9762\u5bf9\u5e94\u7684\u4e00\u81f4\u6027\u95ee\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/SA-NOTES-21/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb020-correspondence-problems",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb020-Correspondence Problems",description:"\u66f2\u9762\u5bf9\u5e94\u95ee\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/SA-NOTES-20/"}},{id:"post-\u4e8c\u53c9\u6811",title:"\u4e8c\u53c9\u6811",description:"LeetCode\u4e8c\u53c9\u6811\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/BinaryTree/"}},{id:"post-\u6808\u4e0e\u961f\u5217",title:"\u6808\u4e0e\u961f\u5217",description:"LeetCode\u6808\u4e0e\u961f\u5217\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/StackQueue/"}},{id:"post-\u53cc\u6307\u9488",title:"\u53cc\u6307\u9488",description:"LeetCode\u53cc\u6307\u9488\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/TwoPointers/"}},{id:"post-\u5b57\u7b26\u4e32",title:"\u5b57\u7b26\u4e32",description:"LeetCode\u5b57\u7b26\u4e32\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/String/"}},{id:"post-\u54c8\u5e0c\u8868",title:"\u54c8\u5e0c\u8868",description:"LeetCode\u54c8\u5e0c\u8868\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/HashTable/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb019-clustering-and-segmentation",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb019-Clustering and Segmentation",description:"\u805a\u7c7b\u548c\u5206\u5272\u95ee\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/SA-NOTES-19/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb018-optimal-transport",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb018-Optimal Transport",description:"\u6700\u4f18\u8fd0\u8f93\u95ee\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/SA-NOTES-18/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb017-optimization-on-manifolds",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb017-Optimization on Manifolds",description:"\u6d41\u5f62\u4e0a\u7684\u4f18\u5316",section:"Posts",handler:()=>{window.location.href="/blog/2023/SA-NOTES-17/"}},{id:"post-\u94fe\u8868",title:"\u94fe\u8868",description:"LeetCode\u94fe\u8868\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/LinkedList/"}},{id:"post-\u6570\u7ec4",title:"\u6570\u7ec4",description:"LeetCode\u6570\u7ec4\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/Array/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb016-vector-fields-discretization",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb016-Vector Fields Discretization",description:"\u79bb\u6563\u66f2\u9762\u4e0a\u7684\u5411\u91cf\u573a",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-16/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb015-vector-fields-introduction",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb015-Vector Fields Introduction",description:"\u5411\u91cf\u573a",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-15/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb014-applications-of-the-laplacian",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb014-Applications of the Laplacian",description:"Laplace\u7b97\u5b50\u7684\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-14/"}},{id:"post-boundary-first-flattening-\u8bba\u6587\u7b14\u8bb0",title:"Boundary First Flattening \u8bba\u6587\u7b14\u8bb0",description:"\u4f5c\u4e1a4\u89e3\u6790\u4e0eBFF\u53c2\u6570\u5316\u7b97\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-BFF/"}},{id:"post-lscm-mean-value-coordinates-\u8bba\u6587\u7b14\u8bb0",title:"LSCM + Mean Value Coordinates \u8bba\u6587\u7b14\u8bb0",description:"\u4f5c\u4e1a3\u89e3\u6790\u4e0eLSCM\u53c2\u6570\u5316\u7b97\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-LSCM+MVC/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb022-gpu-driven-geometry-pipeline-nanite",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb022-GPU-Driven Geometry Pipeline-Nanite",description:"GPU\u9a71\u52a8\u7684\u51e0\u4f55\u7ba1\u7ebf\u4e0eNanite\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-22/"}},{id:"post-a-post-with-giscus-comments",title:"a post with giscus comments",description:"an example of a blog post with giscus comments",section:"Posts",handler:()=>{window.location.href="/blog/2022/giscus-comments/"}},{id:"post-analytic-eigensystems-for-isotropic-distortion-energies-\u8bba\u6587\u7b14\u8bb0",title:"Analytic Eigensystems for Isotropic Distortion Energies \u8bba\u6587\u7b14\u8bb0",description:"\u4f5c\u4e1a2\u89e3\u6790\u4e0eAES\u53c2\u6570\u5316\u7b97\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-AES/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb015-\u53c2\u6570\u5316\u5728\u4ea7\u4e1a\u4e2d\u7684\u5e94\u75282",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb015-\u53c2\u6570\u5316\u5728\u4ea7\u4e1a\u4e2d\u7684\u5e94\u75282",description:"\u66f2\u9762\u53c2\u6570\u5316\u5728\u76f8\u5173\u4ea7\u4e1a\u4e2d\u7684\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-15/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb014-\u53c2\u6570\u5316\u5728\u4ea7\u4e1a\u4e2d\u7684\u5e94\u75281",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb014-\u53c2\u6570\u5316\u5728\u4ea7\u4e1a\u4e2d\u7684\u5e94\u75281",description:"\u66f2\u9762\u53c2\u6570\u5316\u5728\u76f8\u5173\u4ea7\u4e1a\u4e2d\u7684\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-14/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb013-\u53c2\u6570\u5316\u5e94\u75283-\u66f2\u9762\u5bf9\u5e94-\u9ad8\u9636\u591a\u9879\u5f0f\u6620\u5c04",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb013-\u53c2\u6570\u5316\u5e94\u75283(\u66f2\u9762\u5bf9\u5e94\u3001\u9ad8\u9636\u591a\u9879\u5f0f\u6620\u5c04)",description:"\u66f2\u9762\u53c2\u6570\u5316\u7684\u9ad8\u7ea7\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-13/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb012-\u9525\u5947\u5f02\u70b9\u53c2\u6570\u5316\u5e94\u7528",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb012-\u9525\u5947\u5f02\u70b9\u53c2\u6570\u5316\u5e94\u7528",description:"\u9525\u5947\u5f02\u70b9\u53c2\u6570\u5316",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-12/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb011-\u5171\u5f62\u53c2\u6570\u53162-\u79bb\u6563\u5171\u5f62\u7b49\u4ef7\u7c7b-\u66f2\u7387\u6d41",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb011-\u5171\u5f62\u53c2\u6570\u53162(\u79bb\u6563\u5171\u5f62\u7b49\u4ef7\u7c7b\u3001\u66f2\u7387\u6d41)",description:"\u5171\u5f62\u53c2\u6570\u5316\u7684\u57fa\u672c\u7406\u8bba",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-11/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb010-\u5171\u5f62\u53c2\u6570\u53161-circle\u586b\u5145-\u67ef\u897f\u9ece\u66fc\u65b9\u7a0b",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb010-\u5171\u5f62\u53c2\u6570\u53161(Circle\u586b\u5145\u3001\u67ef\u897f\u9ece\u66fc\u65b9\u7a0b)",description:"\u5171\u5f62\u53c2\u6570\u5316\u7684\u57fa\u672c\u7406\u8bba",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-10/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb009-\u57fa\u4e8e\u8c03\u548c\u6620\u5c04\u7684\u9ad8\u8d28\u91cf\u5f62\u53d8",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb009-\u57fa\u4e8e\u8c03\u548c\u6620\u5c04\u7684\u9ad8\u8d28\u91cf\u5f62\u53d8",description:"\u57fa\u4e8e\u8c03\u548c\u6620\u5c04\u7684\u7f51\u683c\u5f62\u53d8\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-09/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb008-\u65e0\u7ffb\u8f6c\u5149\u6ed1\u6620\u5c04",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb008-\u65e0\u7ffb\u8f6c\u5149\u6ed1\u6620\u5c04",description:"\u7f51\u683c\u4e0a\u7684\u65e0\u7ffb\u8f6c\u5149\u6ed1\u6620\u5c04",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-08/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb007-\u53c2\u6570\u5316\u5e94\u75282-\u7f51\u683c\u751f\u6210",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb007-\u53c2\u6570\u5316\u5e94\u75282(\u7f51\u683c\u751f\u6210)",description:"\u66f2\u9762\u53c2\u6570\u5316\u5728\u7f51\u683c\u751f\u6210\u4e2d\u7684\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-07/"}},{id:"post-omscs-ga\u8bfe\u7a0b\u7b14\u8bb007-linear-programming",title:"OMSCS-GA\u8bfe\u7a0b\u7b14\u8bb007-Linear Programming",description:"\u7ebf\u6027\u89c4\u5212",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-GA-NOTES-07/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb006-\u53c2\u6570\u5316\u5e94\u75281-atlas\u751f\u6210-\u827a\u672f\u8bbe\u8ba1",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb006-\u53c2\u6570\u5316\u5e94\u75281(Atlas\u751f\u6210\u3001\u827a\u672f\u8bbe\u8ba1)",description:"\u66f2\u9762\u53c2\u6570\u5316\u5728Atlas\u751f\u6210\u548c\u827a\u672f\u8bbe\u8ba1\u9886\u57df\u4e2d\u7684\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-06/"}},{id:"post-omscs-ga\u8bfe\u7a0b\u7b14\u8bb006-np-completeness",title:"OMSCS-GA\u8bfe\u7a0b\u7b14\u8bb006-NP Completeness",description:"NP\u5b8c\u5907\u7406\u8bba",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-GA-NOTES-06/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb005-\u5168\u5c40\u5355\u5c04\u53c2\u6570\u5316\u65b9\u6cd5",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb005-\u5168\u5c40\u5355\u5c04\u53c2\u6570\u5316\u65b9\u6cd5",description:"\u5168\u5c40\u5355\u5c04\u53c2\u6570\u5316\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-05/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb004-\u65e0\u7ffb\u8f6c\u53c2\u6570\u5316\u65b9\u6cd5-\u521d\u59cb\u65e0\u7ffb\u8f6c",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb004-\u65e0\u7ffb\u8f6c\u53c2\u6570\u5316\u65b9\u6cd5(\u521d\u59cb\u65e0\u7ffb\u8f6c)",description:"\u521d\u59cb\u65e0\u7ffb\u8f6c\u60c5\u51b5\u4e0b\u7684\u7684\u65e0\u7ffb\u8f6c\u53c2\u6570\u5316\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-04/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb003-\u65e0\u7ffb\u8f6c\u53c2\u6570\u5316\u65b9\u6cd5-\u521d\u59cb\u5b58\u5728\u7ffb\u8f6c",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb003-\u65e0\u7ffb\u8f6c\u53c2\u6570\u5316\u65b9\u6cd5(\u521d\u59cb\u5b58\u5728\u7ffb\u8f6c)",description:"\u5b58\u5728\u521d\u59cb\u7ffb\u8f6c\u60c5\u51b5\u4e0b\u7684\u65e0\u7ffb\u8f6c\u53c2\u6570\u5316\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-03/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb002-\u9762\u5411\u79bb\u6563\u7f51\u683c\u7684\u53c2\u6570\u5316\u6982\u8ff0",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb002-\u9762\u5411\u79bb\u6563\u7f51\u683c\u7684\u53c2\u6570\u5316\u6982\u8ff0",description:"\u79bb\u6563\u7f51\u683c\u7684\u53c2\u6570\u5316\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-02/"}},{id:"post-games301\u8bfe\u7a0b\u7b14\u8bb001-\u66f2\u9762\u53c2\u6570\u5316\u4ecb\u7ecd",title:"GAMES301\u8bfe\u7a0b\u7b14\u8bb001-\u66f2\u9762\u53c2\u6570\u5316\u4ecb\u7ecd",description:"\u66f2\u9762\u53c2\u6570\u5316\u7684\u6982\u5ff5\u53ca\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES301-NOTES-01/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb021-dynamic-global-illumination-and-lumen",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb021-Dynamic Global Illumination and Lumen",description:"\u73b0\u4ee3\u6e38\u620f\u5f15\u64ce\u4e2d\u7684\u5168\u5c40\u5149\u7167\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-21/"}},{id:"post-omscs-ga\u8bfe\u7a0b\u7b14\u8bb005-randomized-algorithms",title:"OMSCS-GA\u8bfe\u7a0b\u7b14\u8bb005-Randomized Algorithms",description:"\u5bc6\u7801\u5b66\u4e0e\u968f\u673a\u7b97\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-GA-NOTES-05/"}},{id:"post-omscs-ga\u8bfe\u7a0b\u7b14\u8bb004-max-flow",title:"OMSCS-GA\u8bfe\u7a0b\u7b14\u8bb004-Max Flow",description:"\u6700\u5927\u6d41",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-GA-NOTES-04/"}},{id:"post-omscs-ga\u8bfe\u7a0b\u7b14\u8bb003-graph-algorithms",title:"OMSCS-GA\u8bfe\u7a0b\u7b14\u8bb003-Graph Algorithms",description:"\u56fe\u7b97\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-GA-NOTES-03/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb013-discrete-laplacian-operators",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb013-Discrete Laplacian Operators",description:"\u79bb\u6563Laplace\u7b97\u5b50",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-13/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb012-the-laplacian-operator",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb012-The Laplacian Operator",description:"Laplace\u7b97\u5b50",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-12/"}},{id:"post-omscs-ga\u8bfe\u7a0b\u7b14\u8bb002-divide-and-conquer",title:"OMSCS-GA\u8bfe\u7a0b\u7b14\u8bb002-Divide and Conquer",description:"\u5206\u6cbb\u7b97\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-GA-NOTES-02/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb011-structure-preserving-embedding",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb011-Structure Preserving Embedding",description:"\u6d41\u5f62\u4e0a\u7684\u5d4c\u5165",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-11/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb020-data-oriented-programming-and-job-system",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb020-Data-Oriented Programming and Job System",description:"\u9762\u5411\u6570\u636e\u7f16\u7a0b\u4ee5\u53ca\u4efb\u52a1\u7cfb\u7edf",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-20/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb010-distance-metrics-and-embeddings",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb010-Distance Metrics and Embeddings",description:"\u5ea6\u91cf\u7a7a\u95f4",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-10/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb009-geodesic-distances-algorithms",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb009-Geodesic Distances Algorithms",description:"\u6d4b\u5730\u7ebf\u7684\u8ba1\u7b97",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-09/"}},{id:"post-omscs-ga\u8bfe\u7a0b\u7b14\u8bb001-dynamic-programming",title:"OMSCS-GA\u8bfe\u7a0b\u7b14\u8bb001-Dynamic Programming",description:"\u52a8\u6001\u89c4\u5212",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-GA-NOTES-01/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb008-geodesic-distances-intro-amp-theory",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb008-Geodesic Distances Intro & Theory",description:"\u6d4b\u5730\u7ebf",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-08/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb007-discrete-surface-curvature",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb007-Discrete Surface Curvature",description:"\u79bb\u6563\u66f2\u9762\u4e0a\u7684\u66f2\u7387",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-07/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb006-smooth-surface-curvature",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb006-Smooth Surface Curvature",description:"\u5149\u6ed1\u66f2\u9762\u4e0a\u7684\u66f2\u7387",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-06/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb019-online-gaming-architecture-advanced-topics",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb019-Online Gaming Architecture Advanced Topics",description:"\u7f51\u7edc\u6e38\u620f\u67b6\u6784\u7684\u9ad8\u7ea7\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-19/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb005-smooth-and-discrete-surface",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb005-Smooth and Discrete Surface",description:"\u66f2\u9762\u7406\u8bba",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-05/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb018-online-gaming-architecture-fundamentals",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb018-Online Gaming Architecture Fundamentals",description:"\u7f51\u7edc\u6e38\u620f\u7684\u67b6\u6784\u57fa\u7840",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-18/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb004-discrete-curves",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb004-Discrete Curves",description:"\u79bb\u6563\u66f2\u7ebf",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-04/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb003-continuous-curves",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb003-Continuous Curves",description:"\u8fde\u7eed\u66f2\u7ebf",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-03/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb002-linear-and-variational-problems",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb002-Linear and Variational Problems",description:"\u6570\u5b66\u57fa\u7840",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-02/"}},{id:"post-shape-analysis\u8bfe\u7a0b\u7b14\u8bb001-introduction",title:"Shape Analysis\u8bfe\u7a0b\u7b14\u8bb001-Introduction",description:"\u8bfe\u7a0b\u7b80\u4ecb\u4e0e\u5927\u7eb2",section:"Posts",handler:()=>{window.location.href="/blog/2022/SA-NOTES-01/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb017-advanced-artificial-intelligence",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb017-Advanced Artificial Intelligence",description:"\u6e38\u620fAI\u7684\u9ad8\u7ea7\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-17/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb016-basic-artificial-intelligence",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb016-Basic Artificial Intelligence",description:"\u6e38\u620fAI",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-16/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb015-gameplay-complexity-and-building-blocks",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb015-Gameplay Complexity and Building Blocks",
description:"\u6e38\u620f\u5f15\u64ce\u4e2d\u7684\u73a9\u6cd5\u7cfb\u7edf",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-15/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb014-ccc",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb014-CCC",description:"\u591a\u667a\u80fd\u4f53\u5f3a\u5316\u5b66\u4e60",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-14/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb013-game-theory-revolutions",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb013-Game Theory Revolutions",description:"\u535a\u5f08\u8bba\u57fa\u7840III",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-13/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb012-game-theory-reloaded",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb012-Game Theory Reloaded",description:"\u535a\u5f08\u8bba\u57fa\u7840II",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-12/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb014-applications-amp-advanced-topic",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb014-Applications & Advanced Topic",description:"\u5de5\u5177\u94fe\u7684\u5e94\u7528\u548c\u9ad8\u7ea7\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-14/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb013-foundation-of-tool-chains",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb013-Foundation of Tool Chains",description:"\u6e38\u620f\u5f15\u64ce\u4e2d\u7684\u5de5\u5177\u94fe",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-13/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb011-game-theory",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb011-Game Theory",description:"\u535a\u5f08\u8bba\u57fa\u7840I",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-11/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb010-generalizing-generalizing",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb010-Generalizing Generalizing",description:"\u5f3a\u5316\u5b66\u4e60\u7684\u4e00\u4e9b\u96be\u70b9\u548c\u76f8\u5173\u7684\u5904\u7406\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-10/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb009-partially-observable-mdps",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb009-Partially Observable MDPs",description:"\u90e8\u5206\u53ef\u89c2\u5bdfMDP",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-09/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb008-generalization",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb008-Generalization",description:"\u5f3a\u5316\u5b66\u4e60\u4e2d\u7684\u6cdb\u5316\u95ee\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-08/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb012-effects",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb012-Effects",description:"\u7c92\u5b50\u548c\u58f0\u6548\u7cfb\u7edf",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-12/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb007-exploring-exploration",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb007-Exploring Exploration",description:"\u5f3a\u5316\u5b66\u4e60\u4e2d\u7684\u63a2\u7d22\u95ee\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-07/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb006-messing-with-rewards",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb006-Messing with Rewards",description:"\u5956\u52b1\u51fd\u6570",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-06/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb005-aaa",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb005-AAA",description:"\u5176\u5b83\u7c7b\u578b\u7684\u5f3a\u5316\u5b66\u4e60\u7b97\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-05/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb011-applications-in-physics-system",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb011-Applications in Physics System",description:"\u7269\u7406\u7cfb\u7edf\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-11/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb004-convergence",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb004-Convergence",description:"TD learning\u7b97\u6cd5\u7684\u6536\u655b\u6027",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-04/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb003-td-and-friends",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb003-TD and Friends",description:"TD learning\u7b97\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-03/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb010-basics-concepts-in-physics-system",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb010-Basics Concepts in Physics System",description:"\u6e38\u620f\u5f15\u64ce\u4e2d\u7684\u7269\u7406\u7cfb\u7edf",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-10/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb002-reinforcement-learning-basics",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb002-Reinforcement Learning Basics",description:"\u5f3a\u5316\u5b66\u4e60\u57fa\u7840II",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-02/"}},{id:"post-omscs-rl\u8bfe\u7a0b\u7b14\u8bb001-introduction",title:"OMSCS-RL\u8bfe\u7a0b\u7b14\u8bb001-Introduction",description:"\u5f3a\u5316\u5b66\u4e60\u57fa\u7840I",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-RL-NOTES-01/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb009-advanced-animation-technology",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb009-Advanced Animation Technology",description:"\u52a8\u753b\u7cfb\u7edf\u524d\u6cbf",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-09/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb008-basics-of-animation-technology",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb008-Basics of Animation Technology",description:"\u73b0\u4ee3\u6e38\u620f\u5f15\u64ce\u4e2d\u7684\u52a8\u753b\u7cfb\u7edf",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-08/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb007-render-pipeline-post-process-and-everything",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb007-Render Pipeline, Post-process and Everything",description:"\u73b0\u4ee3\u6e38\u620f\u5f15\u64ce\u4e2d\u7684\u6e32\u67d3\u7ba1\u7ebf\u4ee5\u53ca\u5176\u5b83\u5e38\u7528\u7684\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-07/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb006-the-challenges-and-fun-of-rendering-the-beautiful-mother-nature",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb006-The Challenges and Fun of Rendering the Beautiful Mother Nature",description:"\u5730\u5f62\u548c\u5927\u6c14\u6e32\u67d3\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-06/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb005-lighting-materials-and-shaders",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb005-Lighting, Materials and Shaders",description:"\u73b0\u4ee3\u6e38\u620f\u5f15\u64ce\u7684\u5b9e\u65f6\u6e32\u67d3\u7b97\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-05/"}},{id:"post-omscs-sim\u8bfe\u7a0b\u7b14\u8bb010-comparing-systems",title:"OMSCS-SIM\u8bfe\u7a0b\u7b14\u8bb010-Comparing Systems",description:"\u7cfb\u7edf\u8bc4\u4ef7",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-SIM-NOTES-10/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb019-generative-models",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb019-Generative Models",description:"\u751f\u6210\u5f0f\u6a21\u578b",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-19/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb004-rendering-on-game-engine",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb004-Rendering on Game Engine",description:"\u73b0\u4ee3\u6e38\u620f\u5f15\u64ce\u7684\u6e32\u67d3\u7cfb\u7edf",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-04/"}},{id:"post-omscs-sim\u8bfe\u7a0b\u7b14\u8bb009-output-analysis",title:"OMSCS-SIM\u8bfe\u7a0b\u7b14\u8bb009-Output Analysis",description:"\u8f93\u51fa\u5206\u6790",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-SIM-NOTES-09/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb018-unsupervised-and-semi-supervised-learning",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb018-Unsupervised and Semi-Supervised Learning",description:"\u65e0\u76d1\u7763\u5b66\u4e60\u548c\u534a\u76d1\u7763\u5b66\u4e60",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-18/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb003-how-to-build-a-game-world",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb003-How to Build a Game World",description:"\u73b0\u4ee3\u6e38\u620f\u5f15\u64ce\u7684\u5bf9\u8c61\u8bbe\u8ba1\u548c\u7ba1\u7406\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-03/"}},{id:"post-omscs-sim\u8bfe\u7a0b\u7b14\u8bb008-input-analysis",title:"OMSCS-SIM\u8bfe\u7a0b\u7b14\u8bb008-Input Analysis",description:"\u8f93\u5165\u5206\u6790",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-SIM-NOTES-08/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb017-deep-reinforcement-learning",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb017-Deep Reinforcement Learning",description:"\u6df1\u5ea6\u5f3a\u5316\u5b66\u4e60",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-17/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb002-layered-architecture-of-game-engine",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb002-Layered Architecture of Game Engine",description:"\u73b0\u4ee3\u6e38\u620f\u5f15\u64ce\u7684\u5206\u5c42\u67b6\u6784",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-02/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb016-translation-at-facebook-and-automated-speech-recognition-asr",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb016-Translation at Facebook and Automated Speech Recognition (ASR)",description:"\u673a\u5668\u7ffb\u8bd1\u548c\u8bed\u97f3\u8bc6\u522b",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-16/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb015-neural-machine-translation",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb015-Neural Machine Translation",description:"\u6df1\u5ea6\u5b66\u4e60\u4e0e\u673a\u5668\u7ffb\u8bd1",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-15/"}},{id:"post-games104\u8bfe\u7a0b\u7b14\u8bb001-overview-of-game-engine",title:"GAMES104\u8bfe\u7a0b\u7b14\u8bb001-Overview of Game Engine",description:"\u73b0\u4ee3\u6e38\u620f\u5f15\u64ce\u7684\u57fa\u672c\u6982\u5ff5",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES104-NOTES-01/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb014-neural-attention-models",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb014-Neural Attention Models",description:"\u6ce8\u610f\u529b\u6a21\u578b",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-14/"}},{id:"post-omscs-sim\u8bfe\u7a0b\u7b14\u8bb007-random-variate-generation",title:"OMSCS-SIM\u8bfe\u7a0b\u7b14\u8bb007-Random Variate Generation",description:"\u5e38\u7528\u7684\u968f\u673a\u53d8\u91cf\u751f\u6210\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-SIM-NOTES-07/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb013-embeddings",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb013-Embeddings",description:"\u6df1\u5ea6\u5b66\u4e60\u4e2d\u7684\u5d4c\u5165",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-13/"}},{id:"post-omscs-sim\u8bfe\u7a0b\u7b14\u8bb006-random-number-generation",title:"OMSCS-SIM\u8bfe\u7a0b\u7b14\u8bb006-Random Number Generation",description:"\u5747\u5300\u5206\u5e03\u968f\u673a\u6570\u7684\u751f\u6210\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-SIM-NOTES-06/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb012-language-models",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb012-Language Models",description:"\u8bed\u8a00\u6a21\u578b",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-12/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb011-introduction-to-structured-representations",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb011-Introduction to Structured Representations",description:"\u6df1\u5ea6\u5b66\u4e60\u7684\u7ed3\u6784\u5316\u8868\u793a",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-11/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb010-bias-and-fairness",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb010-Bias and Fairness",description:"\u6df1\u5ea6\u5b66\u4e60\u7684\u516c\u5e73\u6027",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-10/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb009-advanced-computer-vision-architectures",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb009-Advanced Computer Vision Architectures",description:"\u56fe\u50cf\u5206\u5272\u4e0e\u76ee\u6807\u68c0\u6d4b",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-09/"}},{id:"post-omscs-sim\u8bfe\u7a0b\u7b14\u8bb005-arena",title:"OMSCS-SIM\u8bfe\u7a0b\u7b14\u8bb005-Arena",description:"Arena\u8f6f\u4ef6\u7684\u4f7f\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-SIM-NOTES-05/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb008-scalable-training",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb008-Scalable Training",description:"PyTorch\u7684\u53ef\u62d3\u5c55\u6027",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-08/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb007-visualization",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb007-Visualization",description:"\u795e\u7ecf\u7f51\u7edc\u53ef\u89c6\u5316",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-07/"}},{id:"post-omscs-sim\u8bfe\u7a0b\u7b14\u8bb004-general-simulation-principles",title:"OMSCS-SIM\u8bfe\u7a0b\u7b14\u8bb004-General Simulation Principles",description:"\u968f\u673a\u6a21\u62df\u7684\u57fa\u672c\u539f\u5219",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-SIM-NOTES-04/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb006-convolutional-neural-network-architectures",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb006-Convolutional Neural Network Architectures",description:"\u5377\u79ef\u795e\u7ecf\u7f51\u7edc\u7684\u7ed3\u6784",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-06/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb013-\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u9ad8\u7ea7\u5e94\u7528",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb013-\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u9ad8\u7ea7\u5e94\u7528",description:"\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u9ad8\u7ea7\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/GNN-NOTES-13/"}},{id:"post-omscs-sim\u8bfe\u7a0b\u7b14\u8bb003-hand-and-spreadsheet-simulations",title:"OMSCS-SIM\u8bfe\u7a0b\u7b14\u8bb003-Hand and Spreadsheet Simulations",description:"\u968f\u673a\u6a21\u62df\u7684\u57fa\u672c\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-SIM-NOTES-03/"}},{id:"post-a-post-with-redirect",title:"a post with redirect",description:"you can also redirect to assets like pdf",section:"Posts",handler:()=>{window.location.href="/assets/pdf/example_pdf.pdf"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb005-convolution-and-pooling-layers",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb005-Convolution and Pooling Layers",description:"\u5377\u79ef\u795e\u7ecf\u7f51\u7edc",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-05/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb004-data-wrangling",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb004-Data Wrangling",description:"\u6570\u636e\u9884\u5904\u7406",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-04/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb012-\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u9ad8\u7ea7\u65b9\u6cd5",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb012-\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u9ad8\u7ea7\u65b9\u6cd5",description:"\u73b0\u4ee3\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u7814\u7a76\u70ed\u70b9",section:"Posts",handler:()=>{window.location.href="/blog/2022/GNN-NOTES-12/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb003-optimization-of-deep-neural-networks",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb003-Optimization of Deep Neural Networks",description:"\u6df1\u5ea6\u5b66\u4e60\u4e2d\u7684\u4f18\u5316\u7b97\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-03/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb011-\u751f\u7269\u5316\u5b66\u548c\u533b\u7597\u5065\u5eb7\u4e2d\u7684\u56fe\u795e\u7ecf\u7f51\u7edc",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb011-\u751f\u7269\u5316\u5b66\u548c\u533b\u7597\u5065\u5eb7\u4e2d\u7684\u56fe\u795e\u7ecf\u7f51\u7edc",description:"\u56fe\u795e\u7ecf\u7f51\u7edc\u5728\u751f\u7269\u5316\u5b66\u4e2d\u7684\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/GNN-NOTES-11/"}},{id:"post-omscs-sim\u8bfe\u7a0b\u7b14\u8bb002-calculus-probability-and-statistics-primers",title:"OMSCS-SIM\u8bfe\u7a0b\u7b14\u8bb002-Calculus, Probability, and Statistics Primers",description:"\u5fae\u79ef\u5206\u4e0e\u6982\u7387\u8bba\u57fa\u7840",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-SIM-NOTES-02/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb002-neural-networks",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb002-Neural Networks",description:"\u795e\u7ecf\u7f51\u7edc\u57fa\u7840",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-02/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb012-smoothed-particle-hydrodynamics",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb012-Smoothed Particle Hydrodynamics",description:"SPH\u4e0e\u6d41\u4f53\u4eff\u771f",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES103-NOTES-12/"}},{id:"post-omscs-sim\u8bfe\u7a0b\u7b14\u8bb001-whirlwind-tour-of-simulation",title:"OMSCS-SIM\u8bfe\u7a0b\u7b14\u8bb001-Whirlwind Tour of Simulation",description:"\u8ba1\u7b97\u673a\u6a21\u62df\u57fa\u7840",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-SIM-NOTES-01/"}},{id:"post-omscs-dl\u8bfe\u7a0b\u7b14\u8bb001-linear-classifiers-and-gradient-descent",title:"OMSCS-DL\u8bfe\u7a0b\u7b14\u8bb001-Linear Classifiers and Gradient Descent",description:"\u7ebf\u6027\u5206\u7c7b\u5668\u4e0e\u68af\u5ea6\u4e0b\u964d\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2022/OMSCS-DL-NOTES-01/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb011-eulerian-fluids",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb011-Eulerian Fluids",description:"\u4e0d\u53ef\u538b\u7f29\u6d41\u4f53\u4e0eNS\u65b9\u7a0b",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES103-NOTES-11/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb010-\u6570\u636e\u6316\u6398\u4e2d\u7684\u56fe\u795e\u7ecf\u7f51\u7edc",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb010-\u6570\u636e\u6316\u6398\u4e2d\u7684\u56fe\u795e\u7ecf\u7f51\u7edc",description:"\u56fe\u795e\u7ecf\u7f51\u7edc\u5728\u6570\u636e\u6316\u6398\u4e2d\u7684\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2022/GNN-NOTES-10/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb010-surface-waves",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb010-Surface Waves",description:"\u6c34\u6ce2\u6a21\u62df",section:"Posts",handler:()=>{window.location.href="/blog/2022/GAMES103-NOTES-10/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb009-collision-handling",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb009-Collision Handling",description:"\u7269\u7406\u4eff\u771f\u4e2d\u7684\u78b0\u649e\u68c0\u6d4b\u548c\u5904\u7406",section:"Posts",handler:()=>{window.location.href="/blog/2021/GAMES103-NOTES-09/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb009-\u8ba1\u7b97\u673a\u89c6\u89c9\u4e2d\u7684\u56fe\u795e\u7ecf\u7f51\u7edc",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb009-\u8ba1\u7b97\u673a\u89c6\u89c9\u4e2d\u7684\u56fe\u795e\u7ecf\u7f51\u7edc",description:"\u56fe\u795e\u7ecf\u7f51\u7edc\u5728\u8ba1\u7b97\u673a\u89c6\u89c9\u4e2d\u7684\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2021/GNN-NOTES-09/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb008-finite-element-method-ii",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb008-Finite Element Method II",description:"\u5f39\u6027\u4f53\u4eff\u771f\u4e0e\u6709\u9650\u5355\u5143\u6cd5II",section:"Posts",handler:()=>{window.location.href="/blog/2021/GAMES103-NOTES-08/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb007-finite-element-method-i",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb007-Finite Element Method I",description:"\u5f39\u6027\u4f53\u4eff\u771f\u4e0e\u6709\u9650\u5355\u5143\u6cd5I",section:"Posts",handler:()=>{window.location.href="/blog/2021/GAMES103-NOTES-07/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb008-\u81ea\u7136\u8bed\u8a00\u5904\u7406\u4e2d\u7684\u56fe\u795e\u7ecf\u7f51\u7edc",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb008-\u81ea\u7136\u8bed\u8a00\u5904\u7406\u4e2d\u7684\u56fe\u795e\u7ecf\u7f51\u7edc",description:"\u56fe\u795e\u7ecf\u7f51\u7edc\u5728\u81ea\u7136\u8bed\u8a00\u5904\u7406\u4e2d\u7684\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2021/GNN-NOTES-08/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb006-constraint-approaches",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb006-Constraint Approaches",description:"\u5e03\u6599\u4eff\u771f\u4e2d\u7684\u7ea6\u675f\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2021/GAMES103-NOTES-06/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb005-physics-based-cloth-simulation",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb005-Physics-Based Cloth Simulation",description:"\u5e03\u6599\u4eff\u771f",section:"Posts",handler:()=>{window.location.href="/blog/2021/GAMES103-NOTES-05/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb017-3d-perception",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb017-3D Perception",description:"\u4e09\u7ef4\u611f\u77e5",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-17/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb016-binary-morphology",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb016-Binary Morphology",description:"\u6570\u5b66\u5f62\u6001\u5b66",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-16/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb007-\u56fe\u4e0a\u7684\u5176\u4ed6\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb007-\u56fe\u4e0a\u7684\u5176\u4ed6\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b",description:"\u56fe\u795e\u7ecf\u7f51\u7edc\u4e4b\u5916\u7684\u5176\u5b83\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b",section:"Posts",handler:()=>{window.location.href="/blog/2021/GNN-NOTES-07/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb004-rigid-body-contacts",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb004-Rigid Body Contacts",description:"\u521a\u4f53\u78b0\u649e\u4e0e\u63a5\u89e6",section:"Posts",handler:()=>{window.location.href="/blog/2021/GAMES103-NOTES-04/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb015-color-spaces-and-segmentation",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb015-Color Spaces and Segmentation",description:"\u989c\u8272\u7a7a\u95f4\u4e0e\u56fe\u50cf\u5206\u5272",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-15/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb006-\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u53ef\u6269\u5c55\u6027",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb006-\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u53ef\u6269\u5c55\u6027",description:"\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u53ef\u6269\u5c55\u6027",section:"Posts",handler:()=>{window.location.href="/blog/2021/GNN-NOTES-06/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb003-rigid-body-dynamics",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb003-Rigid Body Dynamics",description:"\u521a\u4f53\u52a8\u529b\u5b66",section:"Posts",handler:()=>{window.location.href="/blog/2021/GAMES103-NOTES-03/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb014-action-recognition",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb014-Action Recognition",description:"\u89c6\u9891\u5206\u6790\u548c\u52a8\u4f5c\u8bc6\u522b",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-14/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb002-math-background",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb002-Math Background",description:"\u6570\u5b66\u57fa\u7840",section:"Posts",handler:()=>{window.location.href="/blog/2021/GAMES103-NOTES-02/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb013-discriminative-models",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb013-Discriminative Models",description:"\u5224\u522b\u5f0f\u6a21\u578b",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-13/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb015-game-theory",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb015-Game Theory",description:"\u535a\u5f08\u8bba",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-15/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb005-\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u9c81\u68d2\u6027",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb005-\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u9c81\u68d2\u6027",description:"\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u5bf9\u6297\u653b\u51fb\u548c\u9632\u5fa1",section:"Posts",handler:()=>{window.location.href="/blog/2021/GNN-NOTES-05/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb012-generative-models",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb012-Generative Models",description:"\u56fe\u50cf\u8bc6\u522b\u548c\u751f\u6210\u5f0f\u6a21\u578b",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-12/"}},{id:"post-games103\u8bfe\u7a0b\u7b14\u8bb001-introduction",title:"GAMES103\u8bfe\u7a0b\u7b14\u8bb001-Introduction",description:"\u7269\u7406\u4eff\u771f\u6982\u8ff0",section:"Posts",handler:()=>{window.location.href="/blog/2021/GAMES103-NOTES-01/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb014-reinforcement-learning",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb014-Reinforcement Learning",description:"\u5f3a\u5316\u5b66\u4e60",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-14/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb013-markov-decision-processes",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb013-Markov Decision Processes",description:"Markov\u51b3\u7b56\u8fc7\u7a0b",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-13/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb012-feature-selection-and-transform",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb012-Feature Selection and Transform",description:"\u7279\u5f81\u9009\u62e9",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-12/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb011-tracking",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb011-Tracking",description:"\u76ee\u6807\u8ddf\u8e2a",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-11/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb010-motion-detection",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb010-Motion Detection",description:"\u8fd0\u52a8\u4f30\u8ba1\u4e0e\u5149\u6d41",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-10/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb011-clustering",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb011-Clustering",description:"\u805a\u7c7b\u7b97\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-11/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb004-\u56fe\u795e\u7ecf\u7f51\u7edc",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb004-\u56fe\u795e\u7ecf\u7f51\u7edc",description:"\u56fe\u795e\u7ecf\u7f51\u7edc",section:"Posts",handler:()=>{window.location.href="/blog/2021/GNN-NOTES-04/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb009-lightness-and-brightness",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb009-Lightness and Brightness",description:"\u5149\u7167\u548c\u7740\u8272",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-09/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb010-randomized-optimization",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb010-Randomized Optimization",description:"\u968f\u673a\u4f18\u5316",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-10/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb009-information-theory",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb009-Information Theory",description:"\u4fe1\u606f\u8bba",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-09/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb008-feature-and-matching",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb008-Feature and Matching",description:"\u56fe\u50cf\u7279\u5f81\u4e0e\u5339\u914d",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-08/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb008-bayesian-learning-and-inference",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb008-Bayesian Learning and Inference",description:"\u8d1d\u53f6\u65af\u5b66\u4e60",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-08/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb003-\u56fe\u5d4c\u5165",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb003-\u56fe\u5d4c\u5165",description:"\u56fe\u5d4c\u5165",section:"Posts",handler:()=>{window.location.href="/blog/2021/GNN-NOTES-03/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb007-multiple-views",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb007-Multiple Views",description:"\u591a\u89c6\u56fe\u51e0\u4f55",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-07/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb007-computational-learning-theory",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb007-Computational Learning Theory",description:"\u8ba1\u7b97\u5b66\u4e60\u7406\u8bba",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-07/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb006-camera-calibration",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb006-Camera Calibration",description:"\u76f8\u673a\u6807\u5b9a",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-06/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb006-svm-and-kernel-methods",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb006-SVM and Kernel Methods",description:"\u652f\u6301\u5411\u91cf\u673a",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-06/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb002-\u6df1\u5ea6\u5b66\u4e60\u57fa\u7840",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb002-\u6df1\u5ea6\u5b66\u4e60\u57fa\u7840",description:"\u6df1\u5ea6\u5b66\u4e60\u57fa\u7840",section:"Posts",handler:()=>{window.location.href="/blog/2021/GNN-NOTES-02/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb005-stereo-geometry",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb005-Stereo Geometry",description:"\u7acb\u4f53\u89c6\u89c9",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-05/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb005-ensemble-learning",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb005-Ensemble Learning",description:"\u96c6\u6210\u5b66\u4e60",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-05/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb004-camera-models",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb004-Camera Models",description:"\u76f8\u673a\u6a21\u578b",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-04/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb004-instance-based-learning",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb004-Instance Based Learning",description:"\u5b9e\u4f8b\u5b66\u4e60",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-04/"}},{id:"post-\u6df1\u84dd\u5b66\u9662-gnn\u8bfe\u7a0b\u7b14\u8bb001-\u56fe\u8bba\u57fa\u7840",title:"\u6df1\u84dd\u5b66\u9662-GNN\u8bfe\u7a0b\u7b14\u8bb001-\u56fe\u8bba\u57fa\u7840",description:"\u56fe\u8bba\u57fa\u7840",section:"Posts",handler:()=>{window.location.href="/blog/2021/GNN-NOTES-01/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb003-frequency-domain-analysis",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb003-Frequency Domain Analysis",description:"\u9891\u57df\u5206\u6790",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-03/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb002-hough-transform",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb002-Hough Transform",description:"\u970d\u592b\u53d8\u6362",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-02/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb003-neural-networks",
title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb003-Neural Networks",description:"\u795e\u7ecf\u7f51\u7edc",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-03/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb002-regression",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb002-Regression",description:"\u56de\u5f52\u95ee\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-02/"}},{id:"post-omscs-cv\u8bfe\u7a0b\u7b14\u8bb001-linear-image-processing",title:"OMSCS-CV\u8bfe\u7a0b\u7b14\u8bb001-Linear Image Processing",description:"\u56fe\u50cf\u5904\u7406\u57fa\u7840",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-CV-NOTES-01/"}},{id:"post-omscs-ml\u8bfe\u7a0b\u7b14\u8bb001-decision-trees",title:"OMSCS-ML\u8bfe\u7a0b\u7b14\u8bb001-Decision Trees",description:"\u51b3\u7b56\u6811",section:"Posts",handler:()=>{window.location.href="/blog/2021/OMSCS-ML-NOTES-01/"}},{id:"post-ddg\u8bfe\u7a0b\u7b14\u8bb05-\u6d4b\u5730\u7ebf",title:"DDG\u8bfe\u7a0b\u7b14\u8bb05-\u6d4b\u5730\u7ebf",description:"\u6d4b\u5730\u7ebf\u4e0e\u6d4b\u5730\u8ddd\u79bb",section:"Posts",handler:()=>{window.location.href="/blog/2021/DDG-NOTES-5/"}},{id:"post-ddg\u8bfe\u7a0b\u7b14\u8bb04-\u66f2\u9762\u53c2\u6570\u5316",title:"DDG\u8bfe\u7a0b\u7b14\u8bb04-\u66f2\u9762\u53c2\u6570\u5316",description:"\u66f2\u9762\u53c2\u6570\u5316",section:"Posts",handler:()=>{window.location.href="/blog/2021/DDG-NOTES-4/"}},{id:"post-ddg\u8bfe\u7a0b\u7b14\u8bb03-laplace\u7b97\u5b50",title:"DDG\u8bfe\u7a0b\u7b14\u8bb03-Laplace\u7b97\u5b50",description:"\u66f2\u9762\u4e0a\u7684Laplace\u7b97\u5b50",section:"Posts",handler:()=>{window.location.href="/blog/2021/DDG-NOTES-3/"}},{id:"post-ddg\u8bfe\u7a0b\u7b14\u8bb02-\u66f2\u9762\u4e0e\u66f2\u7387",title:"DDG\u8bfe\u7a0b\u7b14\u8bb02-\u66f2\u9762\u4e0e\u66f2\u7387",description:"\u66f2\u9762\u4e0a\u7684\u66f2\u7387",section:"Posts",handler:()=>{window.location.href="/blog/2021/DDG-NOTES-2/"}},{id:"post-ddg\u8bfe\u7a0b\u7b14\u8bb01-\u5916\u4ee3\u6570\u4e0e\u5916\u5fae\u5206",title:"DDG\u8bfe\u7a0b\u7b14\u8bb01-\u5916\u4ee3\u6570\u4e0e\u5916\u5fae\u5206",description:"\u5916\u4ee3\u6570\u4e0e\u5916\u5fae\u5206\u57fa\u7840",section:"Posts",handler:()=>{window.location.href="/blog/2021/DDG-NOTES-1/"}},{id:"post-a-post-with-diagrams",title:"a post with diagrams",description:"an example of a blog post with diagrams",section:"Posts",handler:()=>{window.location.href="/blog/2021/diagrams/"}},{id:"post-a-distill-style-blog-post",title:"a distill-style blog post",description:"an example of a distill-style blog post and main elements",section:"Posts",handler:()=>{window.location.href="/blog/2021/distill/"}},{id:"post-a-post-with-github-metadata",title:"a post with github metadata",description:"a quick run down on accessing github metadata.",section:"Posts",handler:()=>{window.location.href="/blog/2020/github-metadata/"}},{id:"post-a-post-with-twitter",title:"a post with twitter",description:"an example of a blog post with twitter",section:"Posts",handler:()=>{window.location.href="/blog/2020/twitter/"}},{id:"post-a-post-with-disqus-comments",title:"a post with disqus comments",description:"an example of a blog post with disqus comments",section:"Posts",handler:()=>{window.location.href="/blog/2015/disqus-comments/"}},{id:"post-a-post-with-math",title:"a post with math",description:"an example of a blog post with some math",section:"Posts",handler:()=>{window.location.href="/blog/2015/math/"}},{id:"post-a-post-with-code",title:"a post with code",description:"an example of a blog post with some code",section:"Posts",handler:()=>{window.location.href="/blog/2015/code/"}},{id:"post-a-post-with-images",title:"a post with images",description:"this is what included images could look like",section:"Posts",handler:()=>{window.location.href="/blog/2015/images/"}},{id:"post-a-post-with-formatting-and-links",title:"a post with formatting and links",description:"march & april, looking forward to summer",section:"Posts",handler:()=>{window.location.href="/blog/2015/formatting-and-links/"}},{id:"news-a-simple-inline-announcement",title:"A simple inline announcement.",description:"",section:"News"},{id:"news-a-long-announcement-with-details",title:"A long announcement with details",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_2/"}},{id:"news-a-simple-inline-announcement-with-markdown-emoji-sparkles-smile",title:'A simple inline announcement with Markdown emoji! <img class="emoji" title=":sparkles:" alt=":sparkles:" src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png" height="20" width="20"> <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20">',description:"",section:"News"},{id:"projects-games103-labs",title:"GAMES103 Labs",description:"Homeworks in GAMES 103: Intro to Physics Based Animation.",section:"Projects",handler:()=>{window.location.href="/projects/GAMES103/"}},{id:"projects-nerf-project",title:"NeRF Project",description:"Course project in CS 7643: Deep Learning. We implemented NeRF from scratch.",section:"Projects",handler:()=>{window.location.href="/projects/NeRF_Project/"}},{id:"projects-shape-analysis-homeworks",title:"Shape Analysis Homeworks",description:"Homeworks in MIT 6.838: Shape Analysis.",section:"Projects",handler:()=>{window.location.href="/projects/ShapeAnalysis/"}},{id:"projects-ai4r-projects",title:"AI4R Projects",description:"Course project in CS 7638: Artificial Intelligence for Robotics.",section:"Projects",handler:()=>{window.location.href="/projects/CS7638/"}},{id:"projects-games301-homeworks",title:"GAMES301 Homeworks",description:"Homeworks in GAMES 301: Surface Parameterization.",section:"Projects",handler:()=>{window.location.href="/projects/GAMES301/"}},{id:"projects-lbm-fluid-simulator",title:"LBM Fluid Simulator",description:"A real-time fluid simulator implemented with NVIDIA Warp.",section:"Projects",handler:()=>{window.location.href="/projects/LBM/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%62%70%31%36%35%37@%6E%79%75.%65%64%75","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/peng00bo00","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/bo-peng-9600a4175","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>