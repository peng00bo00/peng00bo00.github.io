<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> C++ STL笔记04-std::vector动态数组 | Bo Peng </title> <meta name="author" content="Bo Peng"> <meta name="description" content="动手实现std::vector"> <meta name="keywords" content="Computer Graphics, Geometry Processing"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400..900&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/favicon.png?cc76d8e6f4495e4cf26b99e34f8aefe4"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://peng00bo00.github.io/blog/2023/STL-NOTES-04/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Bo</span> Peng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Post </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Quick Link </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/blog/tag/formatting">Formatting Guide</a> <a class="dropdown-item " href="/blog/category/leetcode">LeetCode</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">C++ STL笔记04-std::vector动态数组</h1> <p class="post-meta"> Created in November 12, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/code"> <i class="fa-solid fa-hashtag fa-sm"></i> code</a>   <a href="/blog/tag/c"> <i class="fa-solid fa-hashtag fa-sm"></i> C++</a>   ·   <a href="/blog/category/stl"> <i class="fa-solid fa-tag fa-sm"></i> STL</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="stdvector用法">std::vector用法</h2> <p><a href="https://en.cppreference.com/w/cpp/container/vector" rel="external nofollow noopener" target="_blank">std::vector</a>是C++标准库中的一个容器，用于动态数组的实现。<code class="language-plaintext highlighter-rouge">std::vector</code>的特点如下：</p> <ul> <li>顺序序列：容器中的元素按照严格的线性顺序排序，可以通过元素在序列中的位置访问对应的元素；</li> <li>动态数组：支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作；提供了在序列末尾相对快速地添加/删除元素的操作；</li> <li>内存分配器：可以使用一个内存分配器对象来动态地处理它的存储需求。</li> </ul> <p><code class="language-plaintext highlighter-rouge">std::vector</code>有非常丰富的成员函数，这里只展示一些比较常见的用法：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td> <td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 初始化 vector</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myVector</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    
    <span class="c1">// 获取 vector 大小：</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vector size: "</span> <span class="o">&lt;&lt;</span> <span class="n">myVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// 访问元素</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"First element: "</span> <span class="o">&lt;&lt;</span> <span class="n">myVector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// 迭代 vector</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">myVector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myVector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// range-based for循环</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">myVector</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// 在末尾添加元素</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Add 6 to the end: "</span><span class="p">;</span>
    <span class="n">myVector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">myVector</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// 在指定位置插入元素</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Insert 10 to myVector[2]: "</span><span class="p">;</span>
    <span class="n">myVector</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">myVector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">myVector</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// 删除元素</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Remove myVector[3]: "</span><span class="p">;</span>
    <span class="n">myVector</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">myVector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">myVector</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>运行上面的代码可以得到如下结果：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> <td class="rouge-code"><pre>Vector size: 5
First element: 1
1 2 3 4 5 
1 2 3 4 5 
Add 6 to the end: 1 2 3 4 5 6 
Insert 10 to myVector[2]: 1 2 10 3 4 5 6 
Remove myVector[3]: 1 2 10 4 5 6 
</pre></td> </tr></tbody></table></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">std::vector</code>的其它成员函数及其用法可以参考<a href="https://en.cppreference.com/w/cpp/container/vector" rel="external nofollow noopener" target="_blank">官方文档</a>。</p> <h2 id="vector实现">Vector实现</h2> <p>接下来我们从零开始实现一个类似于标准库中<code class="language-plaintext highlighter-rouge">std::vector</code>的动态数组<code class="language-plaintext highlighter-rouge">Vector</code>。</p> <h3 id="模板定义">模板定义</h3> <p><code class="language-plaintext highlighter-rouge">Vector</code>包含两个模板参数：元素类型<code class="language-plaintext highlighter-rouge">T</code>以及内存分配器<code class="language-plaintext highlighter-rouge">Alloc</code>。这里<code class="language-plaintext highlighter-rouge">Alloc</code>用来管理<code class="language-plaintext highlighter-rouge">Vector</code>持有的内存，在大多数情况下使用标准库中的<code class="language-plaintext highlighter-rouge">std::allocator</code>即可。除此之外，<code class="language-plaintext highlighter-rouge">Vector</code>还需要几个额外的成员变量：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">m_data</code>用来指向容器的起点；</li> <li> <code class="language-plaintext highlighter-rouge">m_size</code>用来记录当前数组的大小；</li> <li> <code class="language-plaintext highlighter-rouge">m_cap</code>用来记录容器的容量；</li> <li> <code class="language-plaintext highlighter-rouge">m_alloc</code>用来保存内存分配器<code class="language-plaintext highlighter-rouge">Alloc</code>。</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">m_data</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">m_cap</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">no_unique_address</span><span class="p">]]</span> <span class="n">Alloc</span> <span class="n">m_alloc</span><span class="p">;</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="构造函数">构造函数</h3> <h4 id="默认构造函数">默认构造函数</h4> <p><code class="language-plaintext highlighter-rouge">Vector</code>有各种不同的构造函数用来处理相应的情况。首先是默认构造函数，此时需要将数组初始化为一个空数组，即<code class="language-plaintext highlighter-rouge">m_data</code>为空指针并且数组的大小和容量均为0。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">Vector</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">m_cap</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="参数化构造函数">参数化构造函数</h4> <p>另一种常见使用情况是将<code class="language-plaintext highlighter-rouge">Vector</code>初始化一个大小为<code class="language-plaintext highlighter-rouge">n</code>的数组，此时我们需要把数组的大小和容量都初始化为<code class="language-plaintext highlighter-rouge">n</code>并且对前<code class="language-plaintext highlighter-rouge">n</code>个元素进行默认初始化。由于我们使用了<code class="language-plaintext highlighter-rouge">m_alloc</code>来管理内存，申请内存的过程需要通过<code class="language-plaintext highlighter-rouge">m_alloc</code>来进行实现。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">explicit</span> <span class="n">Vector</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// m_data[i] = 0</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>注意这里使用了<a href="https://en.cppreference.com/w/cpp/memory/construct_at" rel="external nofollow noopener" target="_blank">std::construct_at</a>来初始化<code class="language-plaintext highlighter-rouge">m_data</code>中的元素。此时它会调用<code class="language-plaintext highlighter-rouge">T</code>类型的默认构造函数来进行初始化，从而避免直接使用<code class="language-plaintext highlighter-rouge">new</code>来分配内存和调用构造函数时产生的不必要开销。</p> <p>与之类似的一种情况是使用<code class="language-plaintext highlighter-rouge">val</code>来初始化数组，这里需要在调用<code class="language-plaintext highlighter-rouge">std::construct_at</code>时把<code class="language-plaintext highlighter-rouge">val</code>作为构造函数的参数传进来。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">Vector</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span> <span class="c1">// m_data[i] = val</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>除此之外还可以使用迭代器来初始化<code class="language-plaintext highlighter-rouge">Vector</code>。对于这种情况我们需要先计算出迭代器的大小<code class="language-plaintext highlighter-rouge">n</code>，然后使用迭代器的元素来初始化数组。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">random_access_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="n">Vector</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>在此基础上可以通过初始化列表<code class="language-plaintext highlighter-rouge">std::initializer_list</code>来进行初始化。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">Vector</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span>
    <span class="o">:</span> <span class="n">Vector</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">alloc</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="移动构造函数">移动构造函数</h4> <p>当我们已有一个<code class="language-plaintext highlighter-rouge">Vector</code>对象时可以使用已有的<code class="language-plaintext highlighter-rouge">Vector</code>来初始化一个新的对象。这里我们先实现移动构造函数，这里需要注意在移动构造函数的最后将已有的对象清空。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">;</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>
        <span class="n">m_cap</span>  <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span><span class="p">;</span>

        <span class="n">that</span><span class="p">.</span><span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">;</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>
        <span class="n">m_cap</span>  <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span><span class="p">;</span>

        <span class="n">that</span><span class="p">.</span><span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Vector</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Vector</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">that</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">m_cap</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">m_data</span><span class="p">,</span> <span class="n">m_cap</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">m_data</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">;</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>
        <span class="n">m_cap</span>  <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span><span class="p">;</span>

        <span class="n">that</span><span class="p">.</span><span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="拷贝构造函数">拷贝构造函数</h4> <p>拷贝构造与移动构造类似，不过不需要销毁<code class="language-plaintext highlighter-rouge">that</code>对象。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_size</span><span class="p">);</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">as_const</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_size</span><span class="p">);</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">as_const</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Vector</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Vector</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">that</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

        <span class="n">reserve</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">);</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">as_const</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>最后我们来实现一下析构函数。<code class="language-plaintext highlighter-rouge">Vector</code>的析构函数比较简单，我们需要先逐个析构数组中的元素，然后利用<code class="language-plaintext highlighter-rouge">m_alloc</code>释放内存空间。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="o">~</span><span class="n">Vector</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">m_cap</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">m_data</span><span class="p">,</span> <span class="n">m_cap</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="访问元素">访问元素</h3> <p><code class="language-plaintext highlighter-rouge">Vector</code>允许通过<code class="language-plaintext highlighter-rouge">[]</code>运算符对数组中的元素进行访问。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>当然更安全的访问方式是使用<code class="language-plaintext highlighter-rouge">at()</code>函数，它会在获取元素之前先判断是否越界。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"vector::at"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"vector::at"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>除此之外，<code class="language-plaintext highlighter-rouge">Vector</code>还提供了<code class="language-plaintext highlighter-rouge">front()</code>和<code class="language-plaintext highlighter-rouge">back()</code>函数方便获取数组的首尾元素。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="修改数组大小">修改数组大小</h3> <p><code class="language-plaintext highlighter-rouge">Vector</code>作为动态数组需要允许用户修改数组的大小。这里我们先实现一个<code class="language-plaintext highlighter-rouge">clear()</code>函数用来清空数组，需要注意的是<code class="language-plaintext highlighter-rouge">clear()</code>函数会析构数组中的元素但不会释放数组占用的内存。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>如果用户想要释放掉多余的内存则可以使用<code class="language-plaintext highlighter-rouge">shrink_to_fit()</code>函数将容器的容量减小到与其大小相匹配。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">shrink_to_fit</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">old_data</span> <span class="o">=</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">old_cap</span>  <span class="o">=</span> <span class="n">m_cap</span><span class="p">;</span>

        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_size</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">old_cap</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[[</span><span class="n">likely</span><span class="p">]]</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move_if_noexcept</span><span class="p">(</span><span class="n">old_data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span> <span class="c1">// m_data[i] = std::move(old_data[i])</span>
                <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="n">m_alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">old_data</span><span class="p">,</span> <span class="n">old_cap</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>另一种常见的情况是预先申请一部分内存以便后续对数组进行操作，此时则需要利用<code class="language-plaintext highlighter-rouge">reserve()</code>函数。它会将数组的容量扩充至<code class="language-plaintext highlighter-rouge">n</code>，从而预留出足够的空间。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">reserve</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">m_cap</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m_cap</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">auto</span> <span class="n">old_data</span> <span class="o">=</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">old_cap</span>  <span class="o">=</span> <span class="n">m_cap</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="n">m_cap</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
            <span class="n">m_cap</span>  <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">old_cap</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move_if_noexcept</span><span class="p">(</span><span class="n">old_data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="n">m_alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">old_data</span><span class="p">,</span> <span class="n">old_cap</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>在此基础上我们就可以实现<code class="language-plaintext highlighter-rouge">resize()</code>函数，它会根据参数<code class="language-plaintext highlighter-rouge">n</code>的大小来修改数组。当<code class="language-plaintext highlighter-rouge">n</code>小于数组大小<code class="language-plaintext highlighter-rouge">m_size</code>时截断多出来的部分；而当<code class="language-plaintext highlighter-rouge">n</code>大于<code class="language-plaintext highlighter-rouge">m_size</code>时利用<code class="language-plaintext highlighter-rouge">reserve()</code>函数申请足够的空间。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">resize</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// m_data[i] = 0</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span> <span class="c1">// m_data[i] = val</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="迭代器">迭代器</h3> <p><code class="language-plaintext highlighter-rouge">Vector</code>需要支持迭代器接口。这里我们参考<a href="/2023/10/21/STL-NOTES-03.html#%E8%BF%AD%E4%BB%A3%E5%99%A8">Array</a>中的实现来实现相关的接口。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span>      <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">allocator_type</span>  <span class="o">=</span> <span class="n">Alloc</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">size_type</span>       <span class="o">=</span> <span class="kt">size_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="kt">ptrdiff_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">pointer</span>         <span class="o">=</span> <span class="n">T</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_pointer</span>   <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span>       <span class="o">=</span> <span class="n">T</span> <span class="o">&amp;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_reference</span> <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">iterator</span>        <span class="o">=</span> <span class="n">T</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_iterator</span>  <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">reverse_iterator</span>       <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_reverse_iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">cdata</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span> <span class="n">rbegin</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span> <span class="n">rend</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="n">rbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="n">rend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="n">crbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="n">crend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="修改数组">修改数组</h3> <h4 id="assign">assign()</h4> <p><code class="language-plaintext highlighter-rouge">assign()</code>函数会首先清空数组，然后将数组的前<code class="language-plaintext highlighter-rouge">n</code>个元素设置为<code class="language-plaintext highlighter-rouge">val</code>。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">assign</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>类似于<a href="/2023/11/12/STL-NOTES-04.html#%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">参数化构造函数</a>，这里还实现了几个不同的版本以便处理迭代器和初始化列表做参数的情况。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">random_access_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">assign</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>

        <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assign</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">Vector</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assign</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="push_back">push_back()</h4> <p><code class="language-plaintext highlighter-rouge">push_back()</code>函数会向数组的末尾添加一个新的元素。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">m_cap</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">m_cap</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="emplace_back">emplace_back()</h4> <p><code class="language-plaintext highlighter-rouge">emplace_back()</code>类似于<code class="language-plaintext highlighter-rouge">push_back()</code>同样可以向数组末尾添加元素。不过<code class="language-plaintext highlighter-rouge">emplace_back()</code>函数接收的是<code class="language-plaintext highlighter-rouge">T</code>类型的构造参数，然后直接在数组的末尾利用这些参数构造新的元素，最后返回这个新元素的引用。这里我们使用带变长参数的函数模板来实现它。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">m_cap</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="n">T</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span><span class="p">];</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="pop_back">pop_back()</h4> <p><code class="language-plaintext highlighter-rouge">pop_back()</code>函数会销毁数组的末尾元素。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">pop_back</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="erase">erase()</h4> <p><code class="language-plaintext highlighter-rouge">erase()</code>函数会利用<code class="language-plaintext highlighter-rouge">it</code>指针清除该位置上的元素，并返回数组更新后指向同一位置的指针。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">erase</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">m_size</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span><span class="p">]);</span>

        <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>除此之外我们还可以实现一个针对迭代器的版本，它会清除<code class="language-plaintext highlighter-rouge">first</code>到<code class="language-plaintext highlighter-rouge">last</code>之间的所有元素并返回<code class="language-plaintext highlighter-rouge">first</code>位置的指针。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">erase</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">diff</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">m_size</span> <span class="o">-=</span> <span class="n">diff</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">m_size</span> <span class="o">+</span> <span class="n">diff</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="insert">insert()</h4> <p><code class="language-plaintext highlighter-rouge">insert()</code>函数会在指针<code class="language-plaintext highlighter-rouge">it</code>的位置添加一个新的对象<code class="language-plaintext highlighter-rouge">val</code>，并把后面的对象进行顺延。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">insert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// j ~ m_size =&gt; j + 1 ~ m_size + 1</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">m_size</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>

        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// j ~ m_size =&gt; j + 1 ~ m_size + 1</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">m_size</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>在此基础上，我们可以再实现一个重载版本的<code class="language-plaintext highlighter-rouge">insert()</code>函数在<code class="language-plaintext highlighter-rouge">it</code>后面添加<code class="language-plaintext highlighter-rouge">n</code>个元素。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">insert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>

        <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
        <span class="c1">// j ~ m_size =&gt; j + n ~ m_size + n</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">m_size</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>除此之外，我们还可以实现针对迭代器的版本将<code class="language-plaintext highlighter-rouge">first</code>到<code class="language-plaintext highlighter-rouge">last</code>之间的元素插入到<code class="language-plaintext highlighter-rouge">it</code>位置。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">random_access_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">insert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>

        <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
        <span class="c1">// j ~ m_size =&gt; j + n ~ m_size + n</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">m_size</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="emplace">emplace()</h4> <p><code class="language-plaintext highlighter-rouge">emplace()</code>函数会在指针<code class="language-plaintext highlighter-rouge">it</code>的位置添加一个新的元素。不同于<code class="language-plaintext highlighter-rouge">insert()</code>函数，<code class="language-plaintext highlighter-rouge">emplace()</code>会接收<code class="language-plaintext highlighter-rouge">T</code>类型的构造参数来直接在数组末尾构造出新的对象。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">emplace</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// j ~ m_size =&gt; j + 1 ~ m_size + 1</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">m_size</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>

        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="其它函数">其它函数</h3> <p><code class="language-plaintext highlighter-rouge">Vector</code>中有很多获取内部信息的成员函数。这些成员函数的实现都比较简单，这里总结如下：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">size_t</span> <span class="n">capacity</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_cap</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">max_size</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Alloc</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_alloc</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Vector</code>的<code class="language-plaintext highlighter-rouge">swap()</code>函数可以交换两个<code class="language-plaintext highlighter-rouge">Vector</code>数组内的元素。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Vector</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_data</span><span class="p">,</span>  <span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_size</span><span class="p">,</span>  <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_cap</span><span class="p">,</span>   <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_alloc</span><span class="p">,</span> <span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>不同<code class="language-plaintext highlighter-rouge">Vector</code>对象之间的比较我们则可以利用标准库的相关函数来实现。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> <td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">Vector</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">equal</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="n">Vector</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">lexicographical_compare_three_way</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="完整实现">完整实现</h3> <p>总结一下，整个<code class="language-plaintext highlighter-rouge">Vector</code>的代码可以参考如下：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
</pre></td> <td class="rouge-code"><pre><span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;compare&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;initializer_list&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">allocator_type</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="kt">size_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="kt">ptrdiff_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">T</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_pointer</span> <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">T</span> <span class="o">&amp;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_reference</span> <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">T</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reverse_iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_reverse_iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">;</span>

    <span class="n">T</span> <span class="o">*</span><span class="n">m_data</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">m_cap</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">no_unique_address</span><span class="p">]]</span> <span class="n">Alloc</span> <span class="n">m_alloc</span><span class="p">;</span>

    <span class="n">Vector</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Vector</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span>
    <span class="o">:</span> <span class="n">Vector</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">alloc</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">explicit</span> <span class="nf">Vector</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// m_data[i] = 0</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Vector</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span> <span class="c1">// m_data[i] = val</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">random_access_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="n">Vector</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">Alloc</span><span class="p">())</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// m_data[i] = 0</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span> <span class="c1">// m_data[i] = val</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">shrink_to_fit</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">old_data</span> <span class="o">=</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">old_cap</span> <span class="o">=</span> <span class="n">m_cap</span><span class="p">;</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_size</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">old_cap</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[[</span><span class="n">likely</span><span class="p">]]</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move_if_noexcept</span><span class="p">(</span><span class="n">old_data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span> <span class="c1">// m_data[i] = std::move(old_data[i])</span>
                <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">m_alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">old_data</span><span class="p">,</span> <span class="n">old_cap</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">m_cap</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m_cap</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
        <span class="cm">/* printf("grow from %zd to %zd\n", m_cap, n); */</span>
        <span class="k">auto</span> <span class="n">old_data</span> <span class="o">=</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">old_cap</span> <span class="o">=</span> <span class="n">m_cap</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="n">m_cap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
            <span class="n">m_cap</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">old_cap</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move_if_noexcept</span><span class="p">(</span><span class="n">old_data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">m_alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">old_data</span><span class="p">,</span> <span class="n">old_cap</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">size_t</span> <span class="n">capacity</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_cap</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">max_size</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"vector::at"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"vector::at"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">;</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">;</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Vector</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Vector</span> <span class="o">&amp;&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">that</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_cap</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">m_data</span><span class="p">,</span> <span class="n">m_cap</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">;</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Vector</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_data</span><span class="p">,</span> <span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_size</span><span class="p">,</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_cap</span><span class="p">,</span> <span class="n">that</span><span class="p">.</span><span class="n">m_cap</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_alloc</span><span class="p">,</span> <span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_size</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">as_const</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">,</span> <span class="n">Alloc</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_alloc</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_cap</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="n">m_alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_size</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">as_const</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Vector</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Vector</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">that</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">);</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">m_size</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">as_const</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">m_cap</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">m_cap</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">m_cap</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">T</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span><span class="p">];</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">cdata</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span> <span class="n">rbegin</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span> <span class="n">rend</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="n">rbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="n">rend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="n">crbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="n">crend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_reverse_iterator</span><span class="p">(</span><span class="n">m_data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">pop_back</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">m_size</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="nf">erase</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">m_size</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_size</span><span class="p">]);</span>
        <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="nf">erase</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_data</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">diff</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">m_size</span> <span class="o">-=</span> <span class="n">diff</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">m_size</span> <span class="o">+</span> <span class="n">diff</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">random_access_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">m_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assign</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">Vector</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assign</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="o">*</span><span class="nf">emplace</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// j ~ m_size =&gt; j + 1 ~ m_size + 1</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">m_size</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// j ~ m_size =&gt; j + 1 ~ m_size + 1</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">m_size</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// j ~ m_size =&gt; j + 1 ~ m_size + 1</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">m_size</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
        <span class="c1">// j ~ m_size =&gt; j + n ~ m_size + n</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">m_size</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">random_access_iterator</span> <span class="n">InputIt</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="o">*</span><span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">m_data</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span> <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="n">reserve</span><span class="p">(</span><span class="n">m_size</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
        <span class="c1">// j ~ m_size =&gt; j + n ~ m_size + n</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">m_size</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">m_data</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ilist</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">Vector</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_cap</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">m_data</span><span class="p">,</span> <span class="n">m_cap</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Alloc</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_alloc</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">Vector</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">equal</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="n">Vector</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">lexicographical_compare_three_way</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">that</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h2 id="reference">Reference</h2> <ul> <li><a href="https://github.com/parallel101/stl1weekend/tree/main#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89stl%E5%AE%B9%E5%99%A8" rel="external nofollow noopener" target="_blank">stl1weekend</a></li> <li><a href="https://www.bilibili.com/video/BV1V84y127Pi/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">【C++标准库】自己动手实现vector容器</a></li> </ul> </div> </article> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Bo Peng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-post",title:"Post",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"A growing collection of my projects.",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-cv",title:"CV",description:"\u4e2a\u4eba\u7b80\u5386",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"dropdown-formatting-guide",title:"Formatting Guide",description:"",section:"Dropdown",handler:()=>{window.location.href="/blog/"}},{id:"dropdown-leetcode",title:"LeetCode",description:"",section:"Dropdown",handler:()=>{window.location.href="/blog/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb014-\u6df1\u5ea6\u5b66\u4e60",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb014-\u6df1\u5ea6\u5b66\u4e60",description:"\u751f\u6210\u5f0f\u6a21\u578b\u80cc\u540e\u7684\u6570\u5b66\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-14/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb013-\u4f18\u5316\u57fa\u7840",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb013-\u4f18\u5316\u57fa\u7840",description:"\u56fe\u5f62\u5b66\u4e2d\u5e38\u7528\u7684\u4f18\u5316\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-13/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb012-\u7ebf\u6027\u7cfb\u7edf",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb012-\u7ebf\u6027\u7cfb\u7edf",description:"\u6c42\u89e3\u7ebf\u6027\u7cfb\u7edf\u7684\u76f8\u5173\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-12/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb007-\u6d3b\u52a8\u6807\u67b6\u548c\u5916\u5fae\u5206\u6cd5",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb007-\u6d3b\u52a8\u6807\u67b6\u548c\u5916\u5fae\u5206\u6cd5",description:"\u5fae\u5206\u51e0\u4f55\u4e2d\u7684\u5916\u5fae\u5206\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2024/DifferentialGeometry-NOTES-07/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb011-\u5fae\u5206\u65b9\u7a0b",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb011-\u5fae\u5206\u65b9\u7a0b",description:"\u5fae\u5206\u65b9\u7a0b\u7684\u6c42\u89e3\u65b9\u6cd5",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-11/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb010-\u53e4\u5178\u5fae\u5206\u51e0\u4f55",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb010-\u53e4\u5178\u5fae\u5206\u51e0\u4f55",description:"\u53e4\u5178\u5fae\u5206\u51e0\u4f55\u7684\u57fa\u672c\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-10/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb009-\u573a\u8bba\u521d\u6b65",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb009-\u573a\u8bba\u521d\u6b65",description:"\u573a\u8bba\u7684\u57fa\u672c\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-09/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb008-\u6982\u7387\u8bbaii",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb008-\u6982\u7387\u8bbaII",description:"\u6982\u7387\u8bba\u5728\u56fe\u5f62\u5b66\u4e2d\u7684\u5e94\u7528",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-08/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb006-\u6d4b\u5730\u66f2\u7387\u548c\u6d4b\u5730\u7ebf",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb006-\u6d4b\u5730\u66f2\u7387\u548c\u6d4b\u5730\u7ebf",description:"\u66f2\u9762\u7684\u5185\u8574\u51e0\u4f55",section:"Posts",handler:()=>{window.location.href="/blog/2024/DifferentialGeometry-NOTES-06/"}},{id:"post-a-post-with-tabs",title:"a post with tabs",description:"this is what included tabs in a post could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/tabs/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb007-\u6982\u7387\u8bbai",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb007-\u6982\u7387\u8bbaI",description:"\u6982\u7387\u8bba\u57fa\u7840\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-07/"}},{id:"post-a-post-with-typograms",title:"a post with typograms",description:"this is what included typograms code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/typograms/"}},{id:"post-a-post-that-can-be-cited",title:"a post that can be cited",description:"this is what a post that can be cited looks like",section:"Posts",handler:()=>{window.location.href="/blog/2024/post-citation/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb006-\u5085\u91cc\u53f6\u53d8\u6362\u4e0e\u7403\u8c10\u51fd\u6570",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb006-\u5085\u91cc\u53f6\u53d8\u6362\u4e0e\u7403\u8c10\u51fd\u6570",description:"\u8c31\u53d8\u6362\u4e0e\u7403\u8c10\u51fd\u6570\u76f8\u5173\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-06/"}},{id:"post-a-post-with-pseudo-code",title:"a post with pseudo code",description:"this is what included pseudo code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/pseudocode/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb005-\u63d2\u503c-amp-\u62df\u5408",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb005-\u63d2\u503c&\u62df\u5408",description:"\u51fd\u6570\u63d2\u503c\u4e0e\u62df\u5408\u6280\u672f",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-05/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb004-\u5947\u5f02\u503c\u5206\u89e3\u4e0e\u4e3b\u6210\u5206\u5206\u6790",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb004-\u5947\u5f02\u503c\u5206\u89e3\u4e0e\u4e3b\u6210\u5206\u5206\u6790",description:"SVD\u4e0ePCA\u80cc\u540e\u7684\u6570\u5b66",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-04/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb003-\u65cb\u8f6c\u53d8\u6362",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb003-\u65cb\u8f6c\u53d8\u6362",description:"\u4e09\u7ef4\u65cb\u8f6c\u80cc\u540e\u7684\u6570\u5b66\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-03/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb002-\u8ba1\u7b97\u51e0\u4f55",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb002-\u8ba1\u7b97\u51e0\u4f55",description:"\u8ba1\u7b97\u51e0\u4f55\u76f8\u5173\u5185\u5bb9",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-02/"}},{id:"post-games001\u8bfe\u7a0b\u7b14\u8bb001-\u7ebf\u6027\u4ee3\u6570\u57fa\u7840",title:"GAMES001\u8bfe\u7a0b\u7b14\u8bb001-\u7ebf\u6027\u4ee3\u6570\u57fa\u7840",description:"\u7ebf\u6027\u4ee3\u6570\u57fa\u7840\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2024/GAMES001-NOTES-01/"}},{id:"post-a-post-with-code-diff",title:"a post with code diff",description:"this is how you can display code diffs",section:"Posts",handler:()=>{window.location.href="/blog/2024/code-diff/"}},{id:"post-a-post-with-advanced-image-components",title:"a post with advanced image components",description:"this is what advanced image components could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/advanced-images/"}},{id:"post-a-post-with-vega-lite",title:"a post with vega lite",description:"this is what included vega lite code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/vega-lite/"}},{id:"post-a-post-with-geojson",title:"a post with geojson",description:"this is what included geojson code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/geojson-map/"}},{id:"post-a-post-with-echarts",title:"a post with echarts",description:"this is what included echarts code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/echarts/"}},{id:"post-a-post-with-chart-js",title:"a post with chart.js",description:"this is what included chart.js code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/chartjs/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb005-\u66f2\u9762\u8bba\u57fa\u672c\u5b9a\u7406",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb005-\u66f2\u9762\u8bba\u57fa\u672c\u5b9a\u7406",description:"\u66f2\u9762\u8bba\u57fa\u672c\u5b9a\u7406",section:"Posts",handler:()=>{window.location.href="/blog/2023/DifferentialGeometry-NOTES-05/"}},{id:"post-a-post-with-tikzjax",title:"a post with TikZJax",description:"this is what included TikZ code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2023/tikzjax/"}},{id:"post-c-stl\u7b14\u8bb005-std-list\u53cc\u5411\u94fe\u8868",title:"C++ STL\u7b14\u8bb005-std::list\u53cc\u5411\u94fe\u8868",description:"\u52a8\u624b\u5b9e\u73b0std::list",section:"Posts",handler:()=>{window.location.href="/blog/2023/STL-NOTES-05/"}},{id:"post-c-stl\u7b14\u8bb004-std-vector\u52a8\u6001\u6570\u7ec4",title:"C++ STL\u7b14\u8bb004-std::vector\u52a8\u6001\u6570\u7ec4",description:"\u52a8\u624b\u5b9e\u73b0std::vector",section:"Posts",handler:()=>{window.location.href="/blog/2023/STL-NOTES-04/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb004-\u66f2\u9762\u7684\u7b2c\u4e8c\u57fa\u672c\u5f62\u5f0f",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb004-\u66f2\u9762\u7684\u7b2c\u4e8c\u57fa\u672c\u5f62\u5f0f",description:"\u66f2\u9762\u7684\u7b2c\u4e8c\u57fa\u672c\u5f62\u5f0f",section:"Posts",handler:()=>{window.location.href="/blog/2023/DifferentialGeometry-NOTES-04/"}},{id:"post-c-stl\u7b14\u8bb003-std-array\u6570\u7ec4",title:"C++ STL\u7b14\u8bb003-std::array\u6570\u7ec4",description:"\u52a8\u624b\u5b9e\u73b0std::array",section:"Posts",handler:()=>{window.location.href="/blog/2023/STL-NOTES-03/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb003-\u66f2\u9762\u7684\u7b2c\u4e00\u57fa\u672c\u5f62\u5f0f",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb003-\u66f2\u9762\u7684\u7b2c\u4e00\u57fa\u672c\u5f62\u5f0f",description:"\u66f2\u9762\u7684\u7b2c\u4e00\u57fa\u672c\u5f62\u5f0f",section:"Posts",handler:()=>{window.location.href="/blog/2023/DifferentialGeometry-NOTES-03/"}},{id:"post-c-stl\u7b14\u8bb002-std-unique-ptr\u72ec\u5360\u578b\u667a\u80fd\u6307\u9488",title:"C++ STL\u7b14\u8bb002-std::unique_ptr\u72ec\u5360\u578b\u667a\u80fd\u6307\u9488",description:"\u52a8\u624b\u5b9e\u73b0std::unique_ptr",section:"Posts",handler:()=>{window.location.href="/blog/2023/STL-NOTES-02/"}},{id:"post-c-stl\u7b14\u8bb001-std-function\u5bb9\u5668",title:"C++ STL\u7b14\u8bb001-std::function\u5bb9\u5668",description:"\u52a8\u624b\u5b9e\u73b0std::function",section:"Posts",handler:()=>{window.location.href="/blog/2023/STL-NOTES-01/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb002-\u66f2\u7ebf\u8bba",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb002-\u66f2\u7ebf\u8bba",description:"\u66f2\u7ebf\u8bba\u76f8\u5173\u77e5\u8bc6",section:"Posts",handler:()=>{window.location.href="/blog/2023/DifferentialGeometry-NOTES-02/"}},{id:"post-\u5fae\u5206\u51e0\u4f55\u7b14\u8bb001-\u9884\u5907\u77e5\u8bc6",title:"\u5fae\u5206\u51e0\u4f55\u7b14\u8bb001-\u9884\u5907\u77e5\u8bc6",description:"\u5fae\u5206\u51e0\u4f55\u9884\u5907\u77e5\u8bc6\u4e0e\u5e38\u7528\u7ed3\u8bba",section:"Posts",handler:()=>{window.location.href="/blog/2023/DifferentialGeometry-NOTES-01/"}},{id:"post-a-post-with-bibliography",title:"a post with bibliography",description:"an example of a blog post with bibliography",section:"Posts",handler:()=>{window.location.href="/blog/2023/post-bibliography/"}},{id:"post-a-post-with-jupyter-notebook",title:"a post with jupyter notebook",description:"an example of a blog post with jupyter notebook",section:"Posts",handler:()=>{window.location.href="/blog/2023/jupyter-notebook/"}},{id:"post-a-post-with-custom-blockquotes",title:"a post with custom blockquotes",description:"an example of a blog post with custom blockquotes",section:"Posts",handler:()=>{window.location.href="/blog/2023/custom-blockquotes/"}},{id:"post-a-post-with-table-of-contents-on-a-sidebar",title:"a post with table of contents on a sidebar",description:"an example of a blog post with table of contents on a sidebar",section:"Posts",handler:()=>{window.location.href="/blog/2023/sidebar-table-of-contents/"}},{id:"post-a-post-with-audios",title:"a post with audios",description:"this is what included audios could look like",section:"Posts",handler:()=>{window.location.href="/blog/2023/audios/"}},{id:"post-a-post-with-videos",title:"a post with videos",description:"this is what included videos could look like",section:"Posts",handler:()=>{window.location.href="/blog/2023/videos/"}},{id:"post-\u5e76\u67e5\u96c6",title:"\u5e76\u67e5\u96c6",description:"LeetCode\u5e76\u67e5\u96c6\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/UnionFindSet/"}},{id:"post-\u56fe\u8bba",title:"\u56fe\u8bba",description:"LeetCode\u56fe\u8bba\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/Graph/"}},{id:"post-\u5355\u8c03\u6808",title:"\u5355\u8c03\u6808",description:"LeetCode\u5355\u8c03\u6808\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/MonotoneStack/"}},{id:"post-displaying-beautiful-tables-with-bootstrap-tables",title:"displaying beautiful tables with Bootstrap Tables",description:"an example of how to use Bootstrap Tables",section:"Posts",handler:()=>{window.location.href="/blog/2023/tables/"}},{id:"post-a-post-with-table-of-contents",title:"a post with table of contents",description:"an example of a blog post with table of contents",section:"Posts",handler:()=>{window.location.href="/blog/2023/table-of-contents/"}},{id:"post-\u52a8\u6001\u89c4\u5212",title:"\u52a8\u6001\u89c4\u5212",description:"LeetCode\u52a8\u6001\u89c4\u5212\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/DynamicProgramming/"}},{id:"post-\u8d2a\u5fc3",title:"\u8d2a\u5fc3",description:"LeetCode\u8d2a\u5fc3\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/Greedy/"}},{id:"post-\u56de\u6eaf",title:"\u56de\u6eaf",description:"LeetCode\u56de\u6eaf\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/Backtracking/"}},{id:"post-\u4e8c\u53c9\u6811",title:"\u4e8c\u53c9\u6811",description:"LeetCode\u4e8c\u53c9\u6811\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/BinaryTree/"}},{id:"post-\u6808\u4e0e\u961f\u5217",title:"\u6808\u4e0e\u961f\u5217",description:"LeetCode\u6808\u4e0e\u961f\u5217\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/StackQueue/"}},{id:"post-\u53cc\u6307\u9488",title:"\u53cc\u6307\u9488",description:"LeetCode\u53cc\u6307\u9488\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/TwoPointers/"}},{id:"post-\u5b57\u7b26\u4e32",title:"\u5b57\u7b26\u4e32",description:"LeetCode\u5b57\u7b26\u4e32\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/String/"}},{id:"post-\u54c8\u5e0c\u8868",title:"\u54c8\u5e0c\u8868",description:"LeetCode\u54c8\u5e0c\u8868\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/HashTable/"}},{id:"post-\u94fe\u8868",title:"\u94fe\u8868",description:"LeetCode\u94fe\u8868\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/LinkedList/"}},{id:"post-\u6570\u7ec4",title:"\u6570\u7ec4",description:"LeetCode\u6570\u7ec4\u4e60\u9898",section:"Posts",handler:()=>{window.location.href="/blog/2023/Array/"}},{id:"post-a-post-with-giscus-comments",title:"a post with giscus comments",description:"an example of a blog post with giscus comments",section:"Posts",handler:()=>{window.location.href="/blog/2022/giscus-comments/"}},{id:"post-a-post-with-redirect",title:"a post with redirect",description:"you can also redirect to assets like pdf",section:"Posts",handler:()=>{window.location.href="/assets/pdf/example_pdf.pdf"}},{id:"post-a-post-with-diagrams",title:"a post with diagrams",description:"an example of a blog post with diagrams",section:"Posts",handler:()=>{window.location.href="/blog/2021/diagrams/"}},{id:"post-a-distill-style-blog-post",title:"a distill-style blog post",description:"an example of a distill-style blog post and main elements",section:"Posts",handler:()=>{window.location.href="/blog/2021/distill/"}},{id:"post-a-post-with-github-metadata",title:"a post with github metadata",description:"a quick run down on accessing github metadata.",section:"Posts",handler:()=>{window.location.href="/blog/2020/github-metadata/"}},{id:"post-a-post-with-twitter",title:"a post with twitter",description:"an example of a blog post with twitter",section:"Posts",handler:()=>{window.location.href="/blog/2020/twitter/"}},{id:"post-a-post-with-disqus-comments",title:"a post with disqus comments",description:"an example of a blog post with disqus comments",section:"Posts",handler:()=>{window.location.href="/blog/2015/disqus-comments/"}},{id:"post-a-post-with-math",title:"a post with math",description:"an example of a blog post with some math",section:"Posts",handler:()=>{window.location.href="/blog/2015/math/"}},{id:"post-a-post-with-code",title:"a post with code",description:"an example of a blog post with some code",section:"Posts",handler:()=>{window.location.href="/blog/2015/code/"}},{id:"post-a-post-with-images",title:"a post with images",description:"this is what included images could look like",section:"Posts",handler:()=>{window.location.href="/blog/2015/images/"}},{id:"post-a-post-with-formatting-and-links",title:"a post with formatting and links",description:"march & april, looking forward to summer",section:"Posts",handler:()=>{window.location.href="/blog/2015/formatting-and-links/"}},{id:"news-a-simple-inline-announcement",title:"A simple inline announcement.",description:"",section:"News"},{id:"news-a-long-announcement-with-details",title:"A long announcement with details",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_2/"}},{id:"news-a-simple-inline-announcement-with-markdown-emoji-sparkles-smile",title:'A simple inline announcement with Markdown emoji! <img class="emoji" title=":sparkles:" alt=":sparkles:" src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png" height="20" width="20"> <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20">',description:"",section:"News"},{id:"projects-games103-labs",title:"GAMES103 Labs",description:"Homeworks in GAMES 103: Intro to Physics Based Animation.",section:"Projects",handler:()=>{window.location.href="/projects/GAMES103/"}},{id:"projects-nerf-project",title:"NeRF Project",description:"Course project in CS 7643: Deep Learning. We implemented NeRF from scratch.",section:"Projects",handler:()=>{window.location.href="/projects/NeRF_Project/"}},{id:"projects-shape-analysis-homeworks",title:"Shape Analysis Homeworks",description:"Homeworks in MIT 6.838: Shape Analysis.",section:"Projects",handler:()=>{window.location.href="/projects/ShapeAnalysis/"}},{id:"projects-ai4r-projects",title:"AI4R Projects",description:"Course project in CS 7638: Artificial Intelligence for Robotics.",section:"Projects",handler:()=>{window.location.href="/projects/CS7638/"}},{id:"projects-games301-homeworks",title:"GAMES301 Homeworks",description:"Homeworks in GAMES 301: Surface Parameterization.",section:"Projects",handler:()=>{window.location.href="/projects/GAMES301/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%62%70%31%36%35%37@%6E%79%75.%65%64%75","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/peng00bo00","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/bo-peng-9600a4175","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>