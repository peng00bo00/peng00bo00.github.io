<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 二叉树 | Bo's Blog </title> <meta name="author" content="Bo Peng"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="Computer Graphics, Geometry Processing"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/favicon.png?cc76d8e6f4495e4cf26b99e34f8aefe4"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://peng00bo00.github.io/leetcode/BinaryTree/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Bo's Blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Post </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item active"> <a class="nav-link" href="/leetcode">LeetCode <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">More </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/formatting/">Formatting Guide</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">二叉树</h1> <p class="post-meta"> Created in February 03, 2023 </p> <p class="post-tags"> <i class="fa-solid fa-calendar fa-sm"></i> 2023   ·   <i class="fa-solid fa-hashtag fa-sm"></i> leetcode </p> </header> <article class="post-content"> <div id="markdown-content"> <p><strong>二叉树(binary tree)</strong>是一种基础数据结构。在二叉树中，每个节点除了自身保存的数据外还包含两个指针<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>分别指向左右两个子节点。因此python中二叉树(节点)的定义可参考如下：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> <td class="rouge-code"><pre><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span> 
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h2 id="遍历">遍历</h2> <p>二叉树的经典问题是对树中的节点进行遍历。根据惯例，我们在访问子节点时会按照先左后右的顺序进行遍历。因此根据对当前节点的访问顺序二叉树的遍历可以分为<strong>前序遍历(中左右)</strong>、<strong>中序遍历(左中右)</strong>和<strong>后序遍历(左右中)</strong>三种。</p> <h3 id="144-二叉树的前序遍历">144. 二叉树的前序遍历</h3> <p>给你二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>，返回它节点值的<strong>前序</strong>遍历。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,null,2,3]
输出：[1,2,3]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = []
输出：[]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1]
输出：[1]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例4：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2]
输出：[1,2]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例5：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,null,2]
输出：[1,2]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数目在范围<code class="language-plaintext highlighter-rouge">[0, 100]</code>内。</li> <li>-100 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 100。</li> </ul> <h4 id="solution">Solution</h4> <p>二叉树的遍历有着天然的递归结构，我们只需要按照访问顺序进行递归调用即可。</p> <p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="k">return</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">traversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span>  <span class="n">res</span><span class="p">);</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">preorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>除了递归解法之外，我们还可以使用迭代来进行遍历。和递归相比，通过迭代进行的遍历可以减少函数调用的开销，因此在程序运行时有着更好的性能。二叉树遍历的迭代解法思路是利用栈来模拟程序的递归调用，其模板如下：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> <td class="rouge-code"><pre>while stack or cur:
    while cur:
        stack.append(cur)
        cur 向下遍历
    
    cur = stack.pop()
    使用 cur.left 或 cur.right 来更新 cur
</pre></td> </tr></tbody></table></code></pre></div></div> <p>前序遍历的特点是从当前节点沿左节点自上而下访问沿途节点，然后再自下而上访问沿途节点的右子树。</p> <div align="center"> <img src="https://images.weserv.nl/?url=i.imgur.com/VAD6jmh.png" width="80%"> </div> <p>因此利用循环模板可以得到如下代码。</p> <p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span>

        <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">left</span>

            <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span> 
        
        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">preorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stk</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cur</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="94-二叉树的中序遍历">94. 二叉树的中序遍历</h3> <p>给定一个二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>，返回它的<strong>中序</strong>遍历。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,null,2,3]
输出：[1,3,2]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = []
输出：[]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1]
输出：[1]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数目在范围<code class="language-plaintext highlighter-rouge">[0, 100]</code>内。</li> <li>-100 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 100。</li> </ul> <h4 id="solution-1">Solution</h4> <p>中序遍历的递归解法与<a href="/leetcode/2023-02-03-BinaryTree.html#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">前序遍历</a>类似，只需调整节点上的相对访问顺序即可。</p> <p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">traversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span>  <span class="n">res</span><span class="p">);</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">preorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>中序遍历的节点访问顺序是沿左节点，自下而上访问沿途节点及其右子树。</p> <div align="center"> <img src="https://images.weserv.nl/?url=i.imgur.com/9u57wmH.png" width="80%"> </div> <p>因此在迭代解法中只需要调整向<code class="language-plaintext highlighter-rouge">res</code>添加节点值的顺序即可，此时我们只在出栈时才将节点值添加到<code class="language-plaintext highlighter-rouge">res</code>中。</p> <p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span>

        <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">left</span>
            
            <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stk</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cur</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="145-二叉树的后序遍历">145. 二叉树的后序遍历</h3> <p>给你一棵二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>，返回其节点值的<strong>后序</strong>遍历。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/08/28/pre1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,null,2,3]
输出：[3,2,1]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = []
输出：[]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1]
输出：[1]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数目在范围<code class="language-plaintext highlighter-rouge">[0, 100]</code>内。</li> <li>-100 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 100。</li> </ul> <h4 id="solution-2">Solution</h4> <p>后序遍历的递归解法同样非常简单。</p> <p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">traversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span>  <span class="n">res</span><span class="p">);</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">postorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>后序遍历的迭代解法与前序遍历基本一致，只不过需要先不断向下访问右节点然后再自下而上访问左子树。同时需要注意的是最后要把结果反序输出。</p> <p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>        
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span>

        <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span>
            
            <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">left</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">postorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stk</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cur</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">reverse</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="102-二叉树的层序遍历">102. 二叉树的层序遍历</h3> <p>给你二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>，返回其节点值的<strong>层序遍历</strong>。(即逐层地，从左到右访问所有节点)。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/19/tree1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1]
输出：[[1]]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = []
输出：[]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数目在范围<code class="language-plaintext highlighter-rouge">[0, 2000]</code>内。</li> <li>-1000 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 1000。</li> </ul> <h4 id="solution-3">Solution</h4> <p>二叉树的另一种遍历方式是层序遍历。顾名思义，层序遍历会按照节点所在的层级从左到右依次进行遍历，它的本质是<strong>广度优先搜索(breadth-first search, BFS)</strong>。因此我们可以使用一个队列来存储位于同一层级的节点，然后依次进行访问。</p> <div align="center"> <img src="https://search.pstatic.net/common?src=https://i.imgur.com/UM13bu7.gif" width="60%"> </div> <p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

            <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">levelOrder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">level</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
                <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="n">level</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h2 id="属性">属性</h2> <h3 id="101-对称二叉树">101. 对称二叉树</h3> <p>给你一个二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>，检查它是否轴对称。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/19/symtree1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2,2,3,4,4,3]
输出：true
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/19/symtree2.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2,2,null,3,null,3]
输出：false
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数目在范围<code class="language-plaintext highlighter-rouge">[0, 1000]</code>内。</li> <li>-100 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 100。</li> </ul> <h4 id="solution-4">Solution</h4> <p>判断一棵树是否对称时我们需要考虑它的<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>两棵子树是否对称：</p> <ul> <li>如果<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>均为空则<strong>对称</strong>；</li> <li>如果<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>中一个为空另一个非空则<strong>非对称</strong>；</li> <li>如果<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>均非空但<code class="language-plaintext highlighter-rouge">val</code>不相等则<strong>非对称</strong>；</li> <li>如果<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>均非空且<code class="language-plaintext highlighter-rouge">val</code>相等则需要继续判断。</li> </ul> <p>因此判断树是否对称具有天然的递归结构：当<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>非空且<code class="language-plaintext highlighter-rouge">val</code>相等时则需要进一步考虑树的内外两侧是否分别对称，只有当两侧都是对称时<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>才是对称的。</p> <div align="center"> <img src="https://images.weserv.nl/?url=camo.githubusercontent.com/c6b7e44d2d4a15a2ab7bf066addab1380aab6e9ce15491a4aaca04388abebc7b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230333134343632343431342e706e67" width="60%"> </div> <p><a href="https://leetcode.cn/problems/symmetric-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">T1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">T2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">T1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">T2</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="nf">elif </span><span class="p">(</span><span class="ow">not</span> <span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">T1</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">T2</span><span class="p">.</span><span class="n">val</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
            
            <span class="k">return</span> <span class="nf">compare</span><span class="p">(</span><span class="n">T1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">T2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="nf">compare</span><span class="p">(</span><span class="n">T1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">T2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="nf">compare</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">T1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">T2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">T1</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">T2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">T1</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">T2</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">T1</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">T2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">compare</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">compare</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">compare</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>我们同样可以使用广度优先搜索的思想来处理这样的问题，此时队列中按照由外向内的顺序存储了每一层的一对节点。进行遍历时每次从队列取一对节点进行比较，并且按照由外向内的顺序把它们的子节点加入到队列中。整个比较过程可以参考如下：</p> <div align="center"> <img src="https://search.pstatic.net/common?src=https://i.imgur.com/UO7P6jh.gif"> </div> <p><a href="https://leetcode.cn/problems/symmetric-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
        
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node1</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="n">node2</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>

            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">node1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node2</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="nf">elif </span><span class="p">(</span><span class="ow">not</span> <span class="n">node1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">node1</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">node2</span><span class="p">.</span><span class="n">val</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
            
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node1</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node1</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">True</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>除此之外也可以使用<a href="/leetcode/2023-02-03-BinaryTree.html#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</a>来进行处理，此时只需要考虑每一层是否对称即可。</p> <p><a href="https://leetcode.cn/problems/symmetric-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        
        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">node1</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">node2</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node2</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">node1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">node1</span> <span class="ow">and</span> <span class="n">node2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">elif</span> <span class="n">node1</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">node2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                
                <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">True</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">isSymmetric</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">level</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">level</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
                <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">];</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">n2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">n2</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n1</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">n2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">n2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span> <span class="o">:</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="100-相同的树">100. 相同的树</h3> <p>给你两棵二叉树的根节点<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>，编写一个函数来检验这两棵树是否相同。</p> <p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/12/20/ex1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：p = [1,2,3], q = [1,2,3]
输出：true
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/12/20/ex2.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：p = [1,2], q = [1,null,2]
输出：false
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/12/20/ex3.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：p = [1,2,1], q = [1,1,2]
输出：false
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>两棵树上的节点数目都在范围<code class="language-plaintext highlighter-rouge">[0, 100]</code>内。</li> <li>-10⁴ &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 10⁴。</li> </ul> <h4 id="solution-5">Solution</h4> <p>本题解法与<a href="/leetcode/2023-02-03-BinaryTree.html#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">对称二叉树</a>基本一致，只需分别判断两棵树的相应节点即可。</p> <p><a href="https://leetcode.cn/problems/same-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">q</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="nf">elif </span><span class="p">(</span><span class="ow">not</span> <span class="n">p</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">q</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>python代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="572-另一棵树的子树">572. 另一棵树的子树</h3> <p>给你两棵二叉树<code class="language-plaintext highlighter-rouge">root</code>和<code class="language-plaintext highlighter-rouge">subRoot</code>。检验<code class="language-plaintext highlighter-rouge">root</code>中是否包含和<code class="language-plaintext highlighter-rouge">subRoot</code>具有相同结构和节点值的子树。如果存在，返回<code class="language-plaintext highlighter-rouge">true</code>；否则，返回<code class="language-plaintext highlighter-rouge">false</code>。</p> <p>二叉树<code class="language-plaintext highlighter-rouge">tree</code>的一棵子树包括<code class="language-plaintext highlighter-rouge">tree</code>的某个节点和这个节点的所有后代节点。<code class="language-plaintext highlighter-rouge">tree</code>也可以看做它自身的一棵子树。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li> <code class="language-plaintext highlighter-rouge">root</code>树上的节点数量范围是<code class="language-plaintext highlighter-rouge">[1, 2000]</code>。</li> <li> <code class="language-plaintext highlighter-rouge">subRoot</code>树上的节点数量范围是<code class="language-plaintext highlighter-rouge">[1, 1000]</code>。</li> <li>-10⁴ &lt;= <code class="language-plaintext highlighter-rouge">root.val</code> &lt;= 10⁴。</li> <li>-10⁴ &lt;= <code class="language-plaintext highlighter-rouge">subRoot.val</code> &lt;= 10⁴。</li> </ul> <h4 id="solution-6">Solution</h4> <p>本题解法可参考<a href="/leetcode/2023-02-03-BinaryTree.html#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91">相同的树</a>。我们首先定义一个比较函数<code class="language-plaintext highlighter-rouge">compare(T1, T2)</code>用来判断两棵树是否相同，然后分别测试<code class="language-plaintext highlighter-rouge">root</code>与<code class="language-plaintext highlighter-rouge">subRoot</code>是否相同、<code class="language-plaintext highlighter-rouge">root.left</code>或者<code class="language-plaintext highlighter-rouge">root.right</code>是否包含<code class="language-plaintext highlighter-rouge">subRoot</code>即可。</p> <p><a href="https://leetcode.cn/problems/subtree-of-another-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">T1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">T2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">T1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">T2</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="nf">elif </span><span class="p">(</span><span class="ow">not</span> <span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">T1</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">T2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="k">return</span> <span class="nf">compare</span><span class="p">(</span><span class="n">T1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">T2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="nf">compare</span><span class="p">(</span><span class="n">T1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">T2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">subRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">root</span> <span class="ow">and</span> <span class="n">subRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="k">return</span> <span class="nf">compare</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span> <span class="ow">or</span> <span class="n">self</span><span class="p">.</span><span class="nf">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span> <span class="ow">or</span> <span class="n">self</span><span class="p">.</span><span class="nf">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">T1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">T2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">T1</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">T2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">T1</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">T2</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">T1</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">T2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">compare</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">compare</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">subRoot</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">compare</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span> <span class="o">||</span> <span class="n">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span> <span class="o">||</span> <span class="n">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题的迭代解法则需要使用广度优先或者深度优先对<code class="language-plaintext highlighter-rouge">root</code>进行遍历：如果找到相同的树则返回<code class="language-plaintext highlighter-rouge">True</code>，否则继续向下直到<code class="language-plaintext highlighter-rouge">root</code>中所有节点都进行过比较并最终返回<code class="language-plaintext highlighter-rouge">False</code>。</p> <p><a href="https://leetcode.cn/problems/subtree-of-another-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">T1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">T2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">T1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">T2</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="nf">elif </span><span class="p">(</span><span class="ow">not</span> <span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">T1</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">T2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="k">return</span> <span class="nf">compare</span><span class="p">(</span><span class="n">T1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">T2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="nf">compare</span><span class="p">(</span><span class="n">T1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">T2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>

            <span class="k">if</span> <span class="nf">compare</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">False</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="104-二叉树的最大深度">104. 二叉树的最大深度</h3> <p>给定一个二叉树，找出其最大深度。</p> <p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p> <p><strong>说明: </strong>叶子节点是指没有子节点的节点。</p> <p><strong>示例：</strong> 给定二叉树<code class="language-plaintext highlighter-rouge">[3,9,20,null,null,15,7]</code>，</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> <td class="rouge-code"><pre>    3
   / \
  9  20
    /  \
   15   7
</pre></td> </tr></tbody></table></code></pre></div></div> <p>返回它的最大深度<code class="language-plaintext highlighter-rouge">3</code>。</p> <h4 id="solution-7">Solution</h4> <p>二叉树最大深度的基本解法是使用递归：我们先分别计算左子树和右子树的最大深度<code class="language-plaintext highlighter-rouge">d1</code>和<code class="language-plaintext highlighter-rouge">d2</code>，然后当前节点的最大深度等于<code class="language-plaintext highlighter-rouge">max(d1, d2)+1</code>。</p> <p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="n">d1</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">leftDepth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">rightDepth</span><span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">leftDepth</span><span class="p">,</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>而最大深度的迭代解法则类似于<a href="/leetcode/2023-02-03-BinaryTree.html#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</a>。我们使用一个变量<code class="language-plaintext highlighter-rouge">depth</code>来记录当前的深度，每深入一层就令<code class="language-plaintext highlighter-rouge">depth</code>加一。当队列为空时<code class="language-plaintext highlighter-rouge">depth</code>即为最大深度。</p> <p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">depth</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="o">++</span><span class="n">depth</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="559-n叉树的最大深度">559. N叉树的最大深度</h3> <p>给定一个N叉树，找到其最大深度。</p> <p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p> <p>N叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" width="50%"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,null,3,2,4,null,5,6]
输出：3
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" width="55%"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：5
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="solution-8">Solution</h4> <p>本题解法与<a href="/leetcode/2023-02-03-BinaryTree.html#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">二叉树最大深度</a>基本一致。</p> <p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> <td class="rouge-code"><pre><span class="sh">"""</span><span class="s">
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
</span><span class="sh">"""</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nf">len</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">max</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="nf">maxDepth</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="p">.</span><span class="n">children</span><span class="p">])</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td> <td class="rouge-code"><pre><span class="cm">/*
// Definition for a Node.
class Node {
public:
    int val;
    vector&lt;Node*&gt; children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector&lt;Node*&gt; _children) {
        val = _val;
        children = _children;
    }
};
*/</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">child</span> <span class="o">:</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">child</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="sh">"""</span><span class="s">
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
</span><span class="sh">"""</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">depth</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td> <td class="rouge-code"><pre><span class="cm">/*
// Definition for a Node.
class Node {
public:
    int val;
    vector&lt;Node*&gt; children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector&lt;Node*&gt; _children) {
        val = _val;
        children = _children;
    }
};
*/</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">child</span> <span class="o">:</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="o">++</span><span class="n">depth</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="111-二叉树的最小深度">111. 二叉树的最小深度</h3> <p>给定一个二叉树，找出其最小深度。</p> <p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p> <p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [3,9,20,null,null,15,7]
输出：2
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数的范围在<code class="language-plaintext highlighter-rouge">[0, 10⁵]</code>内。</li> <li>-1000 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 1000。</li> </ul> <h4 id="solution-9">Solution</h4> <p>本题解法与<a href="/leetcode/2023-02-03-BinaryTree.html#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">二叉树最大深度</a>类似，但需要注意的是节点的最小深度并不是左右子树深度的最小值加1，而是需要考虑两棵子树是否存在：</p> <ul> <li>如果左右两棵子树都存在，则当前节点的最小深度是两棵子树深度的最小值加1。</li> <li>如果只有一棵子树存在，则当前节点的最小深度是存在子树的深度加1。</li> <li>如果两棵子树都不存在，则当前节点的深度为1。</li> </ul> <div align="center"> <img src="https://images.weserv.nl/?url=i.imgur.com/6G1rJ9c.png" width="60%"> </div> <p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">minDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">minDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">min</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">minDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">minDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">leftDepth</span> <span class="o">=</span> <span class="n">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">rightDepth</span><span class="o">=</span> <span class="n">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">leftDepth</span><span class="p">,</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">rightDepth</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">leftDepth</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>基于层序遍历的迭代解法思路更加清晰：我们只需要在遍历节点时额外检查当前节点是否为叶节点，如果是叶节点就直接返回深度。</p> <p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">depth</span>
                
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">depth</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="o">++</span><span class="n">depth</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="222-完全二叉树的节点个数">222. 完全二叉树的节点个数</h3> <p>给你一棵<strong>完全二叉树</strong>的根节点<code class="language-plaintext highlighter-rouge">root</code>，求出该树的节点个数。</p> <p><strong>完全二叉树</strong>的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第<code class="language-plaintext highlighter-rouge">h</code>层，则该层包含<code class="language-plaintext highlighter-rouge">1~ 2ʰ</code>个节点。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/01/14/complete.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2,3,4,5,6]
输出：6
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = []
输出：0
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1]
输出：1
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点的数目范围是<code class="language-plaintext highlighter-rouge">[0, 5 * 10⁴]</code>。</li> <li>0 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 5*10⁴。</li> <li>题目数据保证输入的树是<strong>完全二叉树</strong>。</li> </ul> <h4 id="solution-10">Solution</h4> <p>首先按照一般的二叉树来进行求解，我们可以通过深度优先或是广度优先来对树进行遍历。深度优先的时间复杂度为<code class="language-plaintext highlighter-rouge">O(n)</code>，而空间复杂度为<code class="language-plaintext highlighter-rouge">O(log n)</code>。</p> <p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cnt</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">countNodes</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>广度优先的时间复杂度为<code class="language-plaintext highlighter-rouge">O(n)</code>，而空间复杂度为<code class="language-plaintext highlighter-rouge">O(n)</code>。</p> <p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="n">N</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">cnt</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">countNodes</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="n">N</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题的最优解法需要使用到<strong>完全二叉树</strong>的性质。根据定义，完全二叉树要么每一层都被填满，要么只有最下层没被填满。</p> <div align="center"> <img src="https://images.weserv.nl/?url=camo.githubusercontent.com/5d85c9f8df419ce8db22f668ff22f7a3ae55660b8e9bead3b98e2d8cdd69ac9c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313132343039323534333636322e706e67" width="70%"> </div> <p>当二叉树每一层都填满时称为<strong>满二叉树</strong>，此时树中节点数量为<code class="language-plaintext highlighter-rouge">2ʰ-1</code>。在这种情况下我们只需要遍历树的深度就能够得到节点的总数量。而如果完全二叉树不是满二叉树，则只能分别统计两棵子树中节点的数量，然后树中节点总数等于两棵子树节点数量之和加1。这样可以得到递归代码如下，其时间复杂度为<code class="language-plaintext highlighter-rouge">O(log n × log n)</code>，而空间复杂度为<code class="language-plaintext highlighter-rouge">O(log n)</code>。</p> <p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
        <span class="n">right</span><span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>

        <span class="n">leftDepth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rightDepth</span><span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">left</span><span class="p">:</span>
            <span class="n">leftDepth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">.</span><span class="n">left</span>
        
        <span class="k">while</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">rightDepth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">.</span><span class="n">right</span>
        
        <span class="k">if</span> <span class="n">leftDepth</span> <span class="o">==</span> <span class="n">rightDepth</span><span class="p">:</span>
            <span class="nf">return </span><span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">leftDepth</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">countNodes</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">right</span><span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">leftDepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rightDepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="o">++</span><span class="n">leftDepth</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="o">++</span><span class="n">rightDepth</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">leftDepth</span> <span class="o">==</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">leftDepth</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="110-平衡二叉树">110. 平衡二叉树</h3> <p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p> <p>本题中，一棵高度平衡二叉树定义为：</p> <ul> <li>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过<code class="language-plaintext highlighter-rouge">1</code>。</li> </ul> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/10/06/balance_1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [3,9,20,null,null,15,7]
输出：true
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/10/06/balance_2.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = []
输出：true
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中的节点数在范围<code class="language-plaintext highlighter-rouge">[0, 5000]</code>内。</li> <li>-10⁴ &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 10⁴。</li> </ul> <h4 id="solution-11">Solution</h4> <p>本题需要递归计算左右两棵子树的高度，因此我们需要定义一个辅助函数<code class="language-plaintext highlighter-rouge">getHeight(node)</code>：</p> <ul> <li>首先计算左右两棵子树的高度，分别记录到<code class="language-plaintext highlighter-rouge">leftHeight</code>和<code class="language-plaintext highlighter-rouge">rightHeight</code>中；</li> <li>当左子树或右子树不是高度平衡二叉树时返回<code class="language-plaintext highlighter-rouge">-1</code>，表示当前树不可能是高度平衡二叉树；</li> <li>继续比较左右两棵子树的高度之差，如果大于<code class="language-plaintext highlighter-rouge">1</code>则返回<code class="language-plaintext highlighter-rouge">-1</code>表示表示当前树不是高度平衡二叉树；</li> <li>最后返回当前树的高度<code class="language-plaintext highlighter-rouge">1 + max(leftHeight, rightHeight)</code>。</li> </ul> <p>这样判断<code class="language-plaintext highlighter-rouge">root</code>是不是高度平衡二叉树只需要看<code class="language-plaintext highlighter-rouge">getHeight(root)</code>是否等于<code class="language-plaintext highlighter-rouge">-1</code>即可。</p> <p><a href="https://leetcode.cn/problems/balanced-binary-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isBalanced</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">getHeight</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            
            <span class="nf">if </span><span class="p">(</span><span class="n">leftHeight</span> <span class="p">:</span><span class="o">=</span> <span class="nf">getHeight</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">rightHeight</span> <span class="p">:</span><span class="o">=</span> <span class="nf">getHeight</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="nf">abs</span><span class="p">(</span><span class="n">leftHeight</span> <span class="o">-</span> <span class="n">rightHeight</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">max</span><span class="p">(</span><span class="n">leftHeight</span><span class="p">,</span> <span class="n">rightHeight</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="nf">getHeight</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">isBalanced</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">getHeight</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">leftHeight</span> <span class="o">=</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">leftHeight</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">rightHeight</span> <span class="o">=</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rightHeight</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">leftHeight</span> <span class="o">-</span> <span class="n">rightHeight</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">leftHeight</span><span class="p">,</span> <span class="n">rightHeight</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="257-二叉树的所有路径">257. 二叉树的所有路径</h3> <p>给你一个二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>，按<strong>任意顺序</strong>，返回所有从根节点到叶子节点的路径。</p> <p><strong>叶子节点</strong>是指没有子节点的节点。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2,3,null,5]
输出：["1-&gt;2-&gt;5","1-&gt;3"]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1]
输出：["1"]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中的节点数在范围<code class="language-plaintext highlighter-rouge">[0, 100]</code>内。</li> <li>-100 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 100。</li> </ul> <h4 id="solution-12">Solution</h4> <p>本题的基本解法是深度优先搜索：我们自上而下对<code class="language-plaintext highlighter-rouge">root</code>进行遍历，每当遇到叶节点就构造一条路径添加到结果中。因此我们构造一个辅助函数<code class="language-plaintext highlighter-rouge">traverse()</code>，它需要3个输入参数：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">node</code>表示当前节点；</li> <li> <code class="language-plaintext highlighter-rouge">path</code>记录了从<code class="language-plaintext highlighter-rouge">root</code>到<code class="language-plaintext highlighter-rouge">node</code>节点的路径；</li> <li> <code class="language-plaintext highlighter-rouge">res</code>用来保存所有的路径结果。</li> </ul> <p>不难发现，整个遍历过程类似于<a href="/leetcode/2023-02-03-BinaryTree.html#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">前序遍历</a>。</p> <p><a href="https://leetcode.cn/problems/binary-tree-paths/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">binaryTreePaths</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">res</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">path</span><span class="o">+</span><span class="sh">"</span><span class="s">-&gt;</span><span class="sh">"</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span><span class="p">),</span> <span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">path</span><span class="o">+</span><span class="sh">"</span><span class="s">-&gt;</span><span class="sh">"</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">),</span> <span class="n">res</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">res</span>
        
        <span class="k">return</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nf">str</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">),</span> <span class="p">[])</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">binaryTreePaths</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">path</span><span class="p">;</span>

        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">string</span> <span class="n">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">path</span> <span class="o">+=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">path</span> <span class="o">+=</span> <span class="s">"-&gt;"</span><span class="p">;</span>

            <span class="n">traversal</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">path</span> <span class="o">+=</span> <span class="s">"-&gt;"</span><span class="p">;</span>

            <span class="n">traversal</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题的另一种理解方式是<strong>回溯</strong>：当我们访问完叶节点后需要通过回溯的方式来回到上一层的父节点，然后再进入下一个路径。这样的过程可以使用栈来实现。</p> <div align="center"> <img src="https://images.weserv.nl/?url=pic.leetcode-cn.com/1662887575-zcfIKH-image.png" width="70%"> </div> <p><a href="https://leetcode.cn/problems/binary-tree-paths/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">binaryTreePaths</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="n">path_st</span> <span class="o">=</span> <span class="p">[</span><span class="nf">str</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path_st</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">path_st</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="sh">"</span><span class="s">-&gt;</span><span class="sh">"</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">path_st</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="sh">"</span><span class="s">-&gt;</span><span class="sh">"</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题还可以使用回溯模板来进行处理。</p> <p><a href="https://leetcode.cn/problems/binary-tree-paths/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">binaryTreePaths</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">path</span><span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">nonlocal</span> <span class="n">res</span><span class="p">,</span> <span class="n">path</span>

            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">"</span><span class="s">-&gt;</span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">([</span><span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">path</span><span class="p">]))</span>
                <span class="k">return</span>
            
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">child</span><span class="p">:</span>
                    <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="nf">backtracking</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">path</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            
        <span class="nf">backtracking</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="404-左叶子之和">404. 左叶子之和</h3> <p>给定二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>，返回所有左叶子之和。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入: root = [1]
输出: 0
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中的节点数在范围<code class="language-plaintext highlighter-rouge">[0, 1000]</code>内。</li> <li>-1000 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 1000。</li> </ul> <h4 id="solution-13">Solution</h4> <p>本题的难点在于<strong>左叶子</strong>的定义，这里需要先明确它：</p> <ul> <li>一个节点为<strong>左叶子</strong>节点，当且仅当它是某个节点的左子节点，并且它是一个叶子结点。</li> </ul> <p>因此我们无法直接判断当前节点是否是一个左叶子节点，而必须借助它的父节点才能判断。明确定义后我们可以得到递归结构：</p> <ul> <li>计算<code class="language-plaintext highlighter-rouge">root</code>左子树和右子树的左叶子之和，把它们加起来记录到<code class="language-plaintext highlighter-rouge">total</code>中；</li> <li>如果<code class="language-plaintext highlighter-rouge">root.left</code>是左叶子节点，<code class="language-plaintext highlighter-rouge">total</code>还要再加上<code class="language-plaintext highlighter-rouge">root.left.val</code>；</li> <li>返回<code class="language-plaintext highlighter-rouge">total</code>作为当前树的左叶子之和。</li> </ul> <p>不难发现上面的结构类似于<a href="/leetcode/2023-02-03-BinaryTree.html#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">后序遍历</a>。</p> <p><a href="https://leetcode.cn/problems/sum-of-left-leaves/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="n">leftSum</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">rightSum</span><span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="n">total</span> <span class="o">=</span> <span class="n">leftSum</span> <span class="o">+</span> <span class="n">rightSum</span>
        <span class="k">if</span> <span class="nf">isLeaf</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">):</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span>

        <span class="k">return</span> <span class="n">total</span>

<span class="k">def</span> <span class="nf">isLeaf</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    
    <span class="nf">return </span><span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">sumOfLeftLeaves</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">leftSum</span> <span class="o">=</span> <span class="n">sumOfLeftLeaves</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">rightSum</span><span class="o">=</span> <span class="n">sumOfLeftLeaves</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">leftSum</span> <span class="o">+</span> <span class="n">rightSum</span><span class="p">;</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题同样可以使用迭代来进行处理。此时只需要不断检查当前节点的左节点是否是左叶子节点即可，代码可参考如下：</p> <p><a href="https://leetcode.cn/problems/sum-of-left-leaves/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

            <span class="k">if</span> <span class="nf">isLeaf</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">isLeaf</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    
    <span class="nf">return </span><span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">sumOfLeftLeaves</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>

        <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">isLeaf</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">))</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">isLeaf</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="513-找树左下角的值">513. 找树左下角的值</h3> <p>给定一个二叉树的 <strong>根节点</strong> <code class="language-plaintext highlighter-rouge">root</code>，请找出该二叉树的 <strong>最底层</strong> <strong>最左边</strong> 节点的值。</p> <p>假设二叉树中至少有一个节点。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/12/14/tree1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入: root = [2,1,3]
输出: 1
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/12/14/tree2.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中的节点数在范围<code class="language-plaintext highlighter-rouge">[1, 10⁴]</code>内。</li> <li>-2³² &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 2³²-1。</li> </ul> <h4 id="solution-14">Solution</h4> <p>本题的基本解法是使用<a href="/leetcode/2023-02-03-BinaryTree.html#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</a>。根据题意，我们只需要用每一层最左边节点的值来更新<code class="language-plaintext highlighter-rouge">res</code>即可。完成遍历后<code class="language-plaintext highlighter-rouge">res</code>的值即为二叉树最底层最左边节点的值。</p> <p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findBottomLeftValue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">findBottomLeftValue</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">res</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题的另一种解法是使用深度优先搜索。我们需要分别遍历左节点和右节点，然后返回两棵子树最底层最左边节点的值以及对应的深度。这样当前树最底层最左边的值即为两棵子树中拥有最大深度树的返回节点值，相应代码可以参考如下。</p> <p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findBottomLeftValue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="nf">elif </span><span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">depth</span>
            
            <span class="n">leftVal</span><span class="p">,</span> <span class="n">leftDepth</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">rightVal</span><span class="p">,</span> <span class="n">rightDepth</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">leftDepth</span> <span class="o">&gt;=</span> <span class="n">rightDepth</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">leftVal</span><span class="p">,</span> <span class="n">leftDepth</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rightVal</span><span class="p">,</span> <span class="n">rightDepth</span>
        
        <span class="n">res</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">findBottomLeftValue</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">maxDepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">maxDepth</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="n">maxDepth</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">maxDepth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">traversal</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span>  <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">traversal</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="112-路径总和">112. 路径总和</h3> <p>给你二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>和一个表示目标和的整数<code class="language-plaintext highlighter-rouge">targetSum</code>。判断该树中是否存在<strong>根节点到叶子节点</strong>的路径，这条路径上所有节点值相加等于目标和<code class="language-plaintext highlighter-rouge">targetSum</code>。如果存在，返回<code class="language-plaintext highlighter-rouge">true</code>；否则，返回<code class="language-plaintext highlighter-rouge">false</code>。</p> <p><strong>叶子节点</strong>是指没有子节点的节点。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --&gt; 2): 和为 3
(1 --&gt; 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中的节点数在范围<code class="language-plaintext highlighter-rouge">[0, 5000]</code>内。</li> <li>-1000 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 1000。</li> <li>-1000 &lt;= <code class="language-plaintext highlighter-rouge">targetSum</code> &lt;= 1000。</li> </ul> <h4 id="solution-15">Solution</h4> <p>本题可以使用深度优先搜索来求解。我们只需要分别递归遍历左子树和右子树，只要其中存在满足要求的路径即可。</p> <p><a href="https://leetcode.cn/problems/path-sum/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasPathSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">targetSum</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">targetSum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">targetSum</span><span class="o">-</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">targetSum</span><span class="o">-</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">hasPathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">targetSum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">targetSum</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">targetSum</span><span class="o">-</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span> <span class="n">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">targetSum</span><span class="o">-</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题的另一种求解思路是使用回溯。这里我们需要两个栈来分别存储当前遍历到的节点以及路径上节点值之和，这样就可以利用出栈来模拟回溯的过程。具体代码可参考如下。</p> <p><a href="https://leetcode.cn/problems/path-sum/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasPathSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">targetSum</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="n">val_st</span><span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">val</span>  <span class="o">=</span> <span class="n">val_st</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">==</span> <span class="n">targetSum</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">val_st</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">val</span><span class="o">+</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">val_st</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">val</span><span class="o">+</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">False</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="113-路径总和ii">113. 路径总和II</h3> <p>给你二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>和一个整数目标和<code class="language-plaintext highlighter-rouge">targetSum</code>，找出所有<strong>从根节点到叶子节点</strong>路径总和等于给定目标和的路径。</p> <p><strong>叶子节点</strong>是指没有子节点的节点。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2,3], targetSum = 5
输出：[]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2], targetSum = 0
输出：[]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中的节点数在范围<code class="language-plaintext highlighter-rouge">[0, 5000]</code>内。</li> <li>-1000 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 1000。</li> <li>-1000 &lt;= <code class="language-plaintext highlighter-rouge">targetSum</code> &lt;= 1000。</li> </ul> <h4 id="solution-16">Solution</h4> <p>本题解法与<a href="/leetcode/2023-02-03-BinaryTree.html#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C">路径总和</a>基本一致，不过需要注意的是在进行递归时要保存中间结果。</p> <p><a href="https://leetcode.cn/problems/path-sum-ii/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pathSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">targetSum</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span>
            
            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">res</span>
            
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">target</span><span class="o">-</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">path</span><span class="o">+</span><span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span><span class="p">],</span> <span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">target</span><span class="o">-</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">path</span><span class="o">+</span><span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">],</span> <span class="n">res</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">res</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="k">return</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">,</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">],</span> <span class="p">[])</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题的回溯解法相对比较简单，代码可参考如下。</p> <p><a href="https://leetcode.cn/problems/path-sum-ii/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pathSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">targetSum</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="n">stack</span>   <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="n">val_st</span>  <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>
        <span class="n">path_st</span> <span class="o">=</span> <span class="p">[[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">val</span>  <span class="o">=</span> <span class="n">val_st</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path_st</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">==</span> <span class="n">targetSum</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">val_st</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">path_st</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">val_st</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">path_st</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题还可以使用回溯模板来进行处理。</p> <p><a href="https://leetcode.cn/problems/path-sum-ii/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pathSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">targetSum</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">path</span><span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">targetSum</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">nonlocal</span> <span class="n">res</span><span class="p">,</span> <span class="n">path</span>

            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">targetSum</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                <span class="k">return</span>
            
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">child</span><span class="p">:</span>
                    <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="nf">backtracking</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">targetSum</span><span class="o">-</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                    <span class="n">path</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        
        <span class="nf">backtracking</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">targetSum</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>


        <span class="n">path</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>

        <span class="n">backtracking</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">backtracking</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">target</span><span class="o">-</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">backtracking</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">target</span><span class="o">-</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="129-求根节点到叶节点数字之和">129. 求根节点到叶节点数字之和</h3> <p>给你一个二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>，树中每个节点都存放有一个<code class="language-plaintext highlighter-rouge">0</code>到<code class="language-plaintext highlighter-rouge">9</code>之间的数字。</p> <p>每条从根节点到叶节点的路径都代表一个数字：</p> <ul> <li>例如，从根节点到叶节点的路径<code class="language-plaintext highlighter-rouge">1 -&gt; 2 -&gt; 3</code>表示数字<code class="language-plaintext highlighter-rouge">123</code>。</li> </ul> <p>计算从根节点到叶节点生成的<strong>所有数字之和</strong>。</p> <p><strong>叶节点</strong>是指没有子节点的节点。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/19/num1tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1-&gt;2 代表数字 12
从根到叶子节点路径 1-&gt;3 代表数字 13
因此，数字总和 = 12 + 13 = 25
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/19/num2tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> <td class="rouge-code"><pre>输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491
从根到叶子节点路径 4-&gt;0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="solution-17">Solution</h4> <p>本题解法类似于<a href="/leetcode/2023-02-03-BinaryTree.html#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C">路径总和</a>和<a href="/leetcode/2023-02-03-BinaryTree.html#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Cii">路径总和II</a>，整体思路是自上而下遍历整棵树然后把路径上的数字进行相加。</p> <p><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sumNumbers</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">sumPath</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">path</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">nonlocal</span> <span class="n">sumPath</span>

            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
                <span class="n">sumPath</span> <span class="o">+=</span> <span class="n">path</span>
                <span class="k">return</span>
            
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">path</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">path</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        
        <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">sumPath</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sumNumbers</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">sumPath</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">stack</span>   <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="n">path_st</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path_st</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
                <span class="n">sumPath</span> <span class="o">+=</span> <span class="n">path</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">path_st</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">path_st</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">sumPath</span>

</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题还可以使用回溯模板来进行处理。</p> <p><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sumNumbers</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">nonlocal</span> <span class="n">res</span>

            <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">val</span>
                <span class="k">return</span>
            
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">child</span><span class="p">:</span>
                    <span class="nf">backtracking</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">val</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">child</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        
        <span class="nf">backtracking</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">sumNumbers</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">backtracking</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">curSum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">curSum</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">backtracking</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">curSum</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">backtracking</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">curSum</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h2 id="修改与构造">修改与构造</h2> <h3 id="226-翻转二叉树">226. 翻转二叉树</h3> <p>给你一棵二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>，翻转这棵二叉树，并返回其根节点。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [2,1,3]
输出：[2,3,1]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = []
输出：[]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数目在范围<code class="language-plaintext highlighter-rouge">[0, 100]</code>内。</li> <li>-100 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 100。</li> </ul> <h4 id="solution-18">Solution</h4> <p>翻转二叉树是二叉树的经典问题，利用问题自身的递归结构我们可以很容易地得到递归版本的代码。</p> <div align="center"> <img src="https://search.pstatic.net/common?src=https://i.imgur.com/RHTOTSo.gif" width="60%"> </div> <p><a href="https://leetcode.cn/problems/invert-binary-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">invertTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>

        <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">invertTree</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">),</span> <span class="n">self</span><span class="p">.</span><span class="nf">invertTree</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>

        <span class="n">swap</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>当然我们也可以基于迭代来实现翻转，此时只需要利用栈或队列来保存中间节点即可。</p> <p><a href="https://leetcode.cn/problems/invert-binary-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">invertTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>

            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>

        <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stk</span><span class="p">;</span>
        <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="n">swap</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="106-从中序与后序遍历序列构造二叉树">106. 从中序与后序遍历序列构造二叉树</h3> <p>给定两个整数数组<code class="language-plaintext highlighter-rouge">inorder</code>和<code class="language-plaintext highlighter-rouge">postorder</code>，其中<code class="language-plaintext highlighter-rouge">inorder</code>是二叉树的中序遍历，<code class="language-plaintext highlighter-rouge">postorder</code>是同一棵树的后序遍历，请你构造并返回这棵<strong>二叉树</strong>。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/19/tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：inorder = [-1], postorder = [-1]
输出：[-1]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>1 &lt;= <code class="language-plaintext highlighter-rouge">inorder.length</code> &lt;= 3000。</li> <li> <code class="language-plaintext highlighter-rouge">postorder.length</code> == <code class="language-plaintext highlighter-rouge">inorder.length</code>。</li> <li>-3000 &lt;= <code class="language-plaintext highlighter-rouge">inorder[i]</code>, <code class="language-plaintext highlighter-rouge">postorder[i]</code> &lt;= 3000。</li> <li> <code class="language-plaintext highlighter-rouge">inorder</code>和<code class="language-plaintext highlighter-rouge">postorder</code>都由<strong>不同</strong>的值组成。</li> <li> <code class="language-plaintext highlighter-rouge">postorder</code>中每一个值都在<code class="language-plaintext highlighter-rouge">inorder</code>中。</li> <li> <code class="language-plaintext highlighter-rouge">inorder</code><strong>保证</strong>是树的中序遍历。</li> <li> <code class="language-plaintext highlighter-rouge">postorder</code><strong>保证</strong>是树的后序遍历。</li> </ul> <h4 id="solution-19">Solution</h4> <p>本题需要结合<a href="/leetcode/2023-02-03-BinaryTree.html#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a>和<a href="/leetcode/2023-02-03-BinaryTree.html#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">后序遍历</a>的顺序进行求解。回忆中序遍历的顺序为<strong>左-中-右</strong>，而后序遍历为<strong>左-右-中</strong>，因此<code class="language-plaintext highlighter-rouge">postorder</code>的末尾一定是当前的<code class="language-plaintext highlighter-rouge">root</code>。接下来利用<code class="language-plaintext highlighter-rouge">root</code>把<code class="language-plaintext highlighter-rouge">inorder</code>拆成<code class="language-plaintext highlighter-rouge">inorderLeft</code>和<code class="language-plaintext highlighter-rouge">inorderRight</code>两部分，分别对应<code class="language-plaintext highlighter-rouge">root.left</code>和<code class="language-plaintext highlighter-rouge">root.right</code>的中序遍历。类似地，我们还需要再把<code class="language-plaintext highlighter-rouge">postorder</code>同样拆成<code class="language-plaintext highlighter-rouge">postorderLeft</code>和<code class="language-plaintext highlighter-rouge">postorderRight</code>对应后序遍历的左右子树。由于<code class="language-plaintext highlighter-rouge">inorderLeft</code>和<code class="language-plaintext highlighter-rouge">postorderLeft</code>一定具有相同的长度，我们可以直接对<code class="language-plaintext highlighter-rouge">postorder</code>进行拆分。加下来只需要分别递归构造<code class="language-plaintext highlighter-rouge">root.left</code>和<code class="language-plaintext highlighter-rouge">root.right</code>即可。整个算法过程可以参考下图。</p> <div align="center"> <img src="https://images.weserv.nl/?url=i.imgur.com/gG6Z7vv.png"> </div> <p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">inorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">postorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">postorder</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="c1">## the last one in postorder is the root
</span>        <span class="n">val</span> <span class="o">=</span> <span class="n">postorder</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">root</span><span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1">## split idx
</span>        <span class="n">idx</span> <span class="o">=</span> <span class="n">inorder</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">inorderLeft</span> <span class="o">=</span> <span class="n">inorder</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">inorderRight</span><span class="o">=</span> <span class="n">inorder</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">postorderLeft</span> <span class="o">=</span> <span class="n">postorder</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">postorderRight</span><span class="o">=</span> <span class="n">postorder</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1">## recursively build root.left and root.right
</span>        <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">buildTree</span><span class="p">(</span><span class="n">inorderLeft</span><span class="p">,</span> <span class="n">postorderLeft</span><span class="p">)</span>
        <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">buildTree</span><span class="p">(</span><span class="n">inorderRight</span><span class="p">,</span> <span class="n">postorderRight</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">postorder</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">inorder</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">postorder</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">traversal</span><span class="p">(</span><span class="n">inorder</span><span class="p">,</span> <span class="n">postorder</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">postorder</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">postorder</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">postorder</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">postorder</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>

        <span class="kt">int</span> <span class="n">midIdx</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">midIdx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">midIdx</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">midIdx</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inorder</span><span class="p">[</span><span class="n">midIdx</span><span class="p">]</span> <span class="o">==</span> <span class="n">postorder</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">leftInorder</span><span class="p">(</span><span class="n">inorder</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">inorder</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">midIdx</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightInorder</span><span class="p">(</span><span class="n">inorder</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">midIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">inorder</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="n">postorder</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">leftPostorder</span><span class="p">(</span><span class="n">postorder</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">postorder</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">leftInorder</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightPostorder</span><span class="p">(</span><span class="n">postorder</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">leftInorder</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">postorder</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">=</span> <span class="n">traversal</span><span class="p">(</span><span class="n">leftInorder</span><span class="p">,</span> <span class="n">leftPostorder</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">traversal</span><span class="p">(</span><span class="n">rightInorder</span><span class="p">,</span> <span class="n">rightPostorder</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="105-从前序与中序遍历序列构造二叉树">105. 从前序与中序遍历序列构造二叉树</h3> <p>给定两个整数数组<code class="language-plaintext highlighter-rouge">preorder</code>和<code class="language-plaintext highlighter-rouge">inorder</code>，其中<code class="language-plaintext highlighter-rouge">preorder</code>是二叉树的<strong>先序遍历</strong>，<code class="language-plaintext highlighter-rouge">inorder</code>是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/19/tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入: preorder = [-1], inorder = [-1]
输出: [-1]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>1 &lt;= <code class="language-plaintext highlighter-rouge">preorder.length</code> &lt;= 3000。</li> <li> <code class="language-plaintext highlighter-rouge">inorder.length</code> == <code class="language-plaintext highlighter-rouge">preorder.length</code>。</li> <li>-3000 &lt;= <code class="language-plaintext highlighter-rouge">preorder[i]</code>, <code class="language-plaintext highlighter-rouge">inorder[i]</code> &lt;= 3000。</li> <li> <code class="language-plaintext highlighter-rouge">preorder</code>和<code class="language-plaintext highlighter-rouge">inorder</code>均<strong>无重复</strong>元素。</li> <li> <code class="language-plaintext highlighter-rouge">inorder</code>中每一个值都在<code class="language-plaintext highlighter-rouge">preorder</code>中。</li> <li> <code class="language-plaintext highlighter-rouge">preorder</code><strong>保证</strong>为二叉树的前序遍历序列。</li> <li> <code class="language-plaintext highlighter-rouge">inorder</code><strong>保证</strong>为二叉树的中序遍历序列。</li> </ul> <h4 id="solution-20">Solution</h4> <p>本题解法与<a href="/leetcode/2023-02-03-BinaryTree.html#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">从中序与后序遍历序列构造二叉树</a>基本一致，唯一需要注意的是<code class="language-plaintext highlighter-rouge">preorder</code>的第一个元素对应了<code class="language-plaintext highlighter-rouge">root</code>节点。需要额外说明的是如果给定前序和后序遍历是<strong>无法</strong>确定唯一的二叉树的，这是因为没有中序遍历无法确定<code class="language-plaintext highlighter-rouge">root</code>左右部分，也就是无法完成分割。</p> <p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">preorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">inorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preorder</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="c1">## the first one in preorder is the root
</span>        <span class="n">val</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">root</span><span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1">## split idx
</span>        <span class="n">idx</span> <span class="o">=</span> <span class="n">inorder</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">inorderLeft</span> <span class="o">=</span> <span class="n">inorder</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> 
        <span class="n">inorderRight</span><span class="o">=</span> <span class="n">inorder</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">preorderLeft</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">preorderRight</span><span class="o">=</span> <span class="n">preorder</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">idx</span><span class="p">:]</span>

        <span class="c1">## recursively build root.left and root.right
</span>        <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">buildTree</span><span class="p">(</span><span class="n">preorderLeft</span><span class="p">,</span> <span class="n">inorderLeft</span><span class="p">)</span>
        <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">buildTree</span><span class="p">(</span><span class="n">preorderRight</span><span class="p">,</span> <span class="n">inorderRight</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">preorder</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">inorder</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">traversal</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">preorder</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">inorder</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

        <span class="kt">int</span> <span class="n">midIdx</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">midIdx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">midIdx</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">midIdx</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inorder</span><span class="p">[</span><span class="n">midIdx</span><span class="p">]</span> <span class="o">==</span> <span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">leftPreorder</span><span class="p">(</span><span class="n">preorder</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">preorder</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">midIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightPreorder</span><span class="p">(</span><span class="n">preorder</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">midIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">preorder</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">leftInorder</span><span class="p">(</span><span class="n">inorder</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">inorder</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">midIdx</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightInorder</span><span class="p">(</span><span class="n">inorder</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">midIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">inorder</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">=</span> <span class="n">traversal</span><span class="p">(</span><span class="n">leftPreorder</span><span class="p">,</span> <span class="n">leftInorder</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">traversal</span><span class="p">(</span><span class="n">rightPreorder</span><span class="p">,</span> <span class="n">rightInorder</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="654-最大二叉树">654. 最大二叉树</h3> <p>给定一个不重复的整数数组<code class="language-plaintext highlighter-rouge">nums</code>。<strong>最大二叉树</strong>可以用下面的算法从<code class="language-plaintext highlighter-rouge">nums</code>递归地构建:</p> <ul> <li>创建一个根节点，其值为<code class="language-plaintext highlighter-rouge">nums</code>中的最大值。</li> <li>递归地在最大值<strong>左边</strong>的<strong>子数组前缀上</strong>构建左子树。</li> <li>递归地在最大值<strong>右边</strong>的<strong>子数组后缀上</strong>构建右子树。</li> </ul> <p>返回<code class="language-plaintext highlighter-rouge">nums</code>构建的<strong>最大二叉树</strong>。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/12/24/tree1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="rouge-code"><pre>输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/12/24/tree2.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：nums = [3,2,1]
输出：[3,null,2,null,1]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>1 &lt;= <code class="language-plaintext highlighter-rouge">nums.length</code> &lt;= 1000。</li> <li>0 &lt;= <code class="language-plaintext highlighter-rouge">nums[i]</code> &lt;= 1000。</li> <li> <code class="language-plaintext highlighter-rouge">nums</code>中的所有整数<strong>互不相同</strong>。</li> </ul> <h4 id="solution-21">Solution</h4> <p>本题只需要按照题干给出的递归算法进行实现即可。</p> <p><a href="https://leetcode.cn/problems/maximum-binary-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">constructMaximumBinaryTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="n">val</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">num</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span>
        
        <span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1">## recursively build root.left and root.right
</span>        <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">constructMaximumBinaryTree</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">constructMaximumBinaryTree</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">constructMaximumBinaryTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">traversal</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        
        <span class="kt">int</span> <span class="n">rootIdx</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">right</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">rootIdx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">rootIdx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">TreeNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">rootIdx</span><span class="p">]);</span>

        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">=</span> <span class="n">traversal</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">rootIdx</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">traversal</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">rootIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="617-合并二叉树">617. 合并二叉树</h3> <p>给你两棵二叉树：<code class="language-plaintext highlighter-rouge">root1</code>和<code class="language-plaintext highlighter-rouge">root2</code>。</p> <p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为<code class="language-plaintext highlighter-rouge">null</code>的节点将直接作为新二叉树的节点。</p> <p>返回合并后的二叉树。</p> <p><strong>注意</strong>: 合并过程必须从两个树的根节点开始。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/05/merge.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root1 = [1], root2 = [1,2]
输出：[2,2]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>两棵树中的节点数目在范围<code class="language-plaintext highlighter-rouge">[0, 2000]</code>内。</li> <li>-10⁴ &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 10⁴。</li> </ul> <h4 id="solution-22">Solution</h4> <p>本题的递归解法非常直观，我们只需要融合根节点<code class="language-plaintext highlighter-rouge">root1</code>和<code class="language-plaintext highlighter-rouge">root2</code>然后递归地融合左右节点即可。</p> <div align="center"> <img src="https://search.pstatic.net/common?src=https://i.imgur.com/OrMVBCh.gif"> </div> <p><a href="https://leetcode.cn/problems/merge-two-binary-trees/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">root2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root2</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">root2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root1</span>
        
        <span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">root1</span><span class="p">.</span><span class="n">val</span><span class="o">+</span><span class="n">root2</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">mergeTrees</span><span class="p">(</span><span class="n">root1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">mergeTrees</span><span class="p">(</span><span class="n">root1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">mergeTrees</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">root2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">root2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">root1</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">root2</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">root2</span><span class="p">;</span>

        <span class="n">root1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+=</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="n">root1</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">=</span> <span class="n">mergeTrees</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">root1</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">mergeTrees</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题的迭代解法要相对麻烦一些。我们的整体思路是基于<a href="/leetcode/2023-02-03-BinaryTree.html#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</a>，每次向队列中添加两棵树的对应节点并进行更新：</p> <ul> <li>如果两个节点都有左节点，则将两个左节点添加到队列中；</li> <li>如果两个节点都有右节点，则将两个右节点添加到队列中。</li> </ul> <p>这样可以保证队列中的前两个节点都是有效的节点，也因此当前节点的<code class="language-plaintext highlighter-rouge">val</code>等于两个节点<code class="language-plaintext highlighter-rouge">val</code>之和。接下来考虑两个节点中只有一个节点有左节点或右节点的情况，此时只要把该节点的左节点或右节点直接连接到当前节点上即可。整个算法流程可以参考如下。</p> <div align="center"> <img src="https://search.pstatic.net/common?src=https://i.imgur.com/4UTn2Mj.gif" width="80%"> </div> <p><a href="https://leetcode.cn/problems/merge-two-binary-trees/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">root2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root2</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">root2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root1</span>

        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
        
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root1</span><span class="p">,</span> <span class="n">root2</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node1</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="n">node2</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">node1</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">node2</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node1</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">node1</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">node2</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node1</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
            <span class="n">node1</span><span class="p">.</span><span class="n">val</span> <span class="o">+=</span> <span class="n">node2</span><span class="p">.</span><span class="n">val</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">node2</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> 
                <span class="n">node1</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node2</span><span class="p">.</span><span class="n">left</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">node2</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> 
                <span class="n">node1</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node2</span><span class="p">.</span><span class="n">right</span>

        <span class="k">return</span> <span class="n">root1</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h2 id="二叉搜索树">二叉搜索树</h2> <h3 id="700-二叉搜索树中的搜索">700. 二叉搜索树中的搜索</h3> <p>给定二叉搜索树(BST)的根节点<code class="language-plaintext highlighter-rouge">root</code>和一个整数值<code class="language-plaintext highlighter-rouge">val</code>。</p> <p>你需要在BST中找到节点值等于<code class="language-plaintext highlighter-rouge">val</code>的节点。返回以该节点为根的子树。如果节点不存在，则返回<code class="language-plaintext highlighter-rouge">null</code>。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/01/12/tree1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/01/12/tree2.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [4,2,7,1,3], val = 5
输出：[]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数在<code class="language-plaintext highlighter-rouge">[1, 5000]</code>范围内。</li> <li>1 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 10⁷。</li> <li> <code class="language-plaintext highlighter-rouge">root</code>是二叉搜索树。</li> <li>1 &lt;= <code class="language-plaintext highlighter-rouge">val</code> &lt;= 10⁷。</li> </ul> <h4 id="solution-23">Solution</h4> <p>二叉搜索树的递归遍历比较容易。借助节点的顺序我们可以得到递归关系：</p> <ul> <li>当<code class="language-plaintext highlighter-rouge">root.val == val</code>时返回<code class="language-plaintext highlighter-rouge">root</code>；</li> <li>当<code class="language-plaintext highlighter-rouge">root.val &lt; val</code>时向下对右节点继续遍历；</li> <li>当<code class="language-plaintext highlighter-rouge">root.val &gt; val</code>时向下对左节点继续遍历。</li> </ul> <p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">searchBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>
        <span class="k">elif</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">searchBST</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">searchBST</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">searchBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">searchBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">searchBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>而二叉搜索树的迭代遍历也比二叉树的迭代要容易一些。此时我们不再需要借助栈来进行回溯，直接向下遍历即可。</p> <p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">searchBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">root</span>

        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node</span>
            <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
        
        <span class="k">return</span> <span class="bp">None</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">searchBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="98-验证二叉搜索树">98. 验证二叉搜索树</h3> <p>给你一个二叉树的根节点<code class="language-plaintext highlighter-rouge">root</code>，判断其是否是一个有效的二叉搜索树。</p> <p><strong>有效</strong>二叉搜索树定义如下：</p> <ul> <li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li> <li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li> <li>所有左子树和右子树自身必须也是二叉搜索树。</li> </ul> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/12/01/tree1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [2,1,3]
输出：true
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/12/01/tree2.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数目范围在<code class="language-plaintext highlighter-rouge">[1, 10⁴]</code>范围内。</li> <li>-2³¹ &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 2³¹ - 1。</li> </ul> <h4 id="solution-24">Solution</h4> <p>本题的技巧在于对二叉搜索树使用<a href="/leetcode/2023-02-03-BinaryTree.html#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a>进行展开可以得到一个单调递增的序列。因此我们可以按照递归或是迭代的方式来展开<code class="language-plaintext highlighter-rouge">root</code>，然后再验证得到的序列是否满足单调递增条件，如果满足则<code class="language-plaintext highlighter-rouge">root</code>是一个有效的二叉搜索树。对应代码可参考如下。</p> <p><a href="https://leetcode.cn/problems/validate-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            
            <span class="k">return</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="n">vals</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">True</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">left</span>
            
            <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">vals</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">True</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>上面的代码还可以进一步简化。实际上我们并不需要完全将<code class="language-plaintext highlighter-rouge">root</code>展开，只需要记录当前节点的前一个节点<code class="language-plaintext highlighter-rouge">pre</code>并且比较它们是否单调递增即可。</p> <p><a href="https://leetcode.cn/problems/validate-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">nonlocal</span> <span class="n">pre</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            
            <span class="n">validLeft</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">pre</span> <span class="ow">and</span> <span class="n">pre</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            
            <span class="c1">## update pre
</span>            <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span>

            <span class="n">validRight</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">validLeft</span> <span class="ow">and</span> <span class="n">validRight</span>
        
        <span class="k">return</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">left</span>
            
            <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">pre</span> <span class="ow">and</span> <span class="n">pre</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            
            <span class="c1">## update pre and cur
</span>            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span>
        
        <span class="k">return</span> <span class="bp">True</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">isValidBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stk</span><span class="p">;</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="n">cur</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="530-二叉搜索树的最小绝对差">530. 二叉搜索树的最小绝对差</h3> <p>给你一个二叉搜索树的根节点<code class="language-plaintext highlighter-rouge">root</code>，返回<strong>树中任意两不同节点值之间的最小差值</strong>。</p> <p>差值是一个正数，其数值等于两值之差的绝对值。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/05/bst1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [4,2,6,1,3]
输出：1
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/05/bst2.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,0,48,null,null,12,49]
输出：1
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数目范围在<code class="language-plaintext highlighter-rouge">[2, 10⁴]</code>范围内。</li> <li>0 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 10⁵。</li> </ul> <h4 id="solution-25">Solution</h4> <p>本题解法与<a href="/leetcode/2023-02-03-BinaryTree.html#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">验证二叉搜索树</a>类似，都是利用<a href="/leetcode/2023-02-03-BinaryTree.html#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a>对二叉搜索树进行展开。展开后序列相邻元素的最小绝对值之差即为所求。</p> <p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getMinimumDifference</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            
            <span class="k">return</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="n">vals</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">minDiff</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">minDiff</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">minDiff</span><span class="p">,</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">minDiff</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getMinimumDifference</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vals</span>  <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cur</span>   <span class="o">=</span> <span class="n">root</span>

        <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">left</span>
            
            <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">vals</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span>
        
        <span class="n">minDiff</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">minDiff</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">minDiff</span><span class="p">,</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">minDiff</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>我们同样可以简化二叉搜索树的展开过程。这里使用<code class="language-plaintext highlighter-rouge">pre</code>来记录当前节点的前一个节点，<code class="language-plaintext highlighter-rouge">minDiff</code>来记录当前遍历过程中的相邻节点最小绝对值之差。这样只需要在遍历过程中不断对它们进行更新即可，递归和迭代版本的代码可以参考如下。</p> <p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getMinimumDifference</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">minDiff</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">"</span><span class="s">inf</span><span class="sh">"</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">nonlocal</span> <span class="n">minDiff</span><span class="p">,</span> <span class="n">pre</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>

            <span class="c1">## update minDiff
</span>            <span class="k">if</span> <span class="n">pre</span><span class="p">:</span>
                <span class="n">minDiff</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">minDiff</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="o">-</span><span class="n">pre</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            
            <span class="c1">## update pre
</span>            <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span>

            <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">minDiff</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getMinimumDifference</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pre</span>   <span class="o">=</span> <span class="bp">None</span>
        <span class="n">cur</span>   <span class="o">=</span> <span class="n">root</span>
        <span class="n">minDiff</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">"</span><span class="s">inf</span><span class="sh">"</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">left</span>
            
            <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            
            <span class="c1">## update minDiff
</span>            <span class="k">if</span> <span class="n">pre</span><span class="p">:</span>
                <span class="n">minDiff</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">minDiff</span><span class="p">,</span> <span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="o">-</span><span class="n">pre</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>

            <span class="c1">## update pre and minDiff
</span>            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span>
        
        <span class="k">return</span> <span class="n">minDiff</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">getMinimumDifference</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stk</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">minDiff</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cur</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">minDiff</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">minDiff</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">-</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>

            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">minDiff</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="501-二叉搜索树中的众数">501. 二叉搜索树中的众数</h3> <p>给你一个含重复值的二叉搜索树(BST)的根节点<code class="language-plaintext highlighter-rouge">root</code>，找出并返回BST中的所有<strong>众数</strong>(即，出现频率最高的元素)。</p> <p>如果树中有不止一个众数，可以按<strong>任意顺序</strong>返回。</p> <p>假定BST满足如下定义：</p> <ul> <li>结点左子树中所含节点的值<strong>小于等于</strong>当前节点的值</li> <li>结点右子树中所含节点的值<strong>大于等于</strong>当前节点的值</li> <li>左子树和右子树都是二叉搜索树</li> </ul> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,null,2,2]
输出：[2]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [0]
输出：[0]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数目范围在<code class="language-plaintext highlighter-rouge">[1, 10⁴]</code>范围内。</li> <li>-10⁵ &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 10⁵。</li> </ul> <h4 id="solution-26">Solution</h4> <p>本题的技巧同样是二叉搜索树<a href="/leetcode/2023-02-03-BinaryTree.html#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a>可以展开为单调序列。由于序列是单调不减的，我们只需要一次遍历就可以得到众数。具体来说我们使用<code class="language-plaintext highlighter-rouge">count</code>来记录当前节点出现的次数，<code class="language-plaintext highlighter-rouge">maxCount</code>来记录最大出现次数。如果<code class="language-plaintext highlighter-rouge">count == maxCount</code>则把当前值加入到<code class="language-plaintext highlighter-rouge">res</code>中，而如果<code class="language-plaintext highlighter-rouge">count &gt; maxCount</code>则清空<code class="language-plaintext highlighter-rouge">res</code>并使其只包含当前节点值。递归和迭代版本的代码可参考如下。</p> <p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findMode</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">nonlocal</span> <span class="n">pre</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">maxCount</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>

            <span class="c1">## update count
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">pre</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">pre</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">count</span><span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
            
            <span class="c1">## update maxCount and res
</span>            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">maxCount</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">maxCount</span><span class="p">:</span>
                <span class="n">maxCount</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>
            
            <span class="c1">## update pre
</span>            <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span>
            
            <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findMode</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pre</span>   <span class="o">=</span> <span class="bp">None</span>
        <span class="n">cur</span>   <span class="o">=</span> <span class="n">root</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">left</span>
            
            <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

            <span class="c1">## update count
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">pre</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">pre</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1">## update maxCount and res
</span>            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">maxCount</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">maxCount</span><span class="p">:</span>
                <span class="n">maxCount</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>

            <span class="c1">## update pre and cur
</span>            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findMode</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stk</span><span class="p">;</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">count</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cur</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">pre</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">++</span><span class="n">count</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">maxCount</span><span class="p">)</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">maxCount</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">maxCount</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

                <span class="n">res</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="538-把二叉搜索树转换为累加树">538. 把二叉搜索树转换为累加树</h3> <p>给出二叉<strong>搜索</strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树(Greater Sum Tree)，使每个节点<code class="language-plaintext highlighter-rouge">node</code>的新值等于原树中大于或等于<code class="language-plaintext highlighter-rouge">node.val</code>的值之和。</p> <p>提醒一下，二叉搜索树满足下列约束条件：</p> <ul> <li>节点的左子树仅包含键<strong>小于</strong>节点键的节点。</li> <li>节点的右子树仅包含键<strong>大于</strong>节点键的节点。</li> <li>左右子树也必须是二叉搜索树。</li> </ul> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [0,null,1]
输出：[1,null,1]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,0,2]
输出：[3,3,2]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例4：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [3,2,4,1]
输出：[7,9,4,10]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中的节点数介于0和10⁴之间。</li> <li>每个节点的值介于10⁴和10⁴之间。</li> <li>树中的所有值<strong>互不相同</strong>。</li> <li>给定的树为二叉搜索树。</li> </ul> <h4 id="solution-27">Solution</h4> <p>本题解法与<a href="/leetcode/2023-02-03-BinaryTree.html#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a>类似，不过需要按照<strong>右中左</strong>的顺序进行遍历。利用二叉搜索树的性质把上一个节点更新后的值加到当前节点上即可。</p> <p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">convertBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            
            <span class="k">nonlocal</span> <span class="n">pre</span>
            
            <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">pre</span><span class="p">:</span>
                <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">+=</span> <span class="n">pre</span><span class="p">.</span><span class="n">val</span>
            
            <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span>
            
            <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">root</span>

        <span class="k">return</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>迭代解法可参考如下。</p> <p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">convertBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span>
        
        <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span>
            
            <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">pre</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="n">val</span> <span class="o">+=</span> <span class="n">pre</span><span class="p">.</span><span class="n">val</span>

            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">left</span>
        
        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">convertBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stk</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cur</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>

            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h2 id="公共祖先">公共祖先</h2> <h3 id="236-二叉树的最近公共祖先">236. 二叉树的最近公共祖先</h3> <p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p> <p>最近公共祖先的定义为：对于有根树<code class="language-plaintext highlighter-rouge">T</code>的两个节点<code class="language-plaintext highlighter-rouge">p</code>、<code class="language-plaintext highlighter-rouge">q</code>，最近公共祖先表示为一个节点<code class="language-plaintext highlighter-rouge">x</code>，满足<code class="language-plaintext highlighter-rouge">x</code>是<code class="language-plaintext highlighter-rouge">p</code>、<code class="language-plaintext highlighter-rouge">q</code>的祖先且<code class="language-plaintext highlighter-rouge">x</code>的深度尽可能大(一个节点也可以是它自己的祖先)。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2018/12/14/binarytree.png"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2018/12/14/binarytree.png"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2], p = 1, q = 2
输出：1
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点数目范围在<code class="language-plaintext highlighter-rouge">[2, 10⁵]</code>范围内。</li> <li>-10⁹ &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 10⁹。</li> <li>所有<code class="language-plaintext highlighter-rouge">Node.val</code>互不相同。</li> <li> <code class="language-plaintext highlighter-rouge">p</code> != <code class="language-plaintext highlighter-rouge">q</code>。</li> <li> <code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>均存在于给定的二叉树中。</li> </ul> <h4 id="solution-28">Solution</h4> <p>本题的解法在于自下而上对二叉树进行遍历，这相当于<a href="/leetcode/2023-02-03-BinaryTree.html#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">后序遍历</a>的过程。如果当前节点<code class="language-plaintext highlighter-rouge">root</code>为空或是等于<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>则直接返回<code class="language-plaintext highlighter-rouge">root</code>，然后再对左子树以及右子树进行递归遍历并将结果分别记录到<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>中：</p> <ul> <li>如果<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>均非空则说明当前节点<code class="language-plaintext highlighter-rouge">root</code>是最近公共祖先，返回<code class="language-plaintext highlighter-rouge">root</code>；</li> <li>如果<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>只有一个非空则返回非空的节点。</li> </ul> <p>整个递归过程可参考下图。</p> <div align="center"> <img src="https://images.weserv.nl/?url=i.imgur.com/IUQ9Lem.png" width="70%"> </div> <p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span> <span class="ow">or</span> <span class="n">root</span> <span class="o">==</span> <span class="n">p</span> <span class="ow">or</span> <span class="n">root</span> <span class="o">==</span> <span class="n">q</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>
        
        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="n">right</span><span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>
        <span class="k">if</span> <span class="n">left</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left</span>
        <span class="k">return</span> <span class="n">right</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span>  <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">right</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="235-二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</h3> <p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p> <p>最近公共祖先的定义为：对于有根树<code class="language-plaintext highlighter-rouge">T</code>的两个节点<code class="language-plaintext highlighter-rouge">p</code>、<code class="language-plaintext highlighter-rouge">q</code>，最近公共祖先表示为一个节点<code class="language-plaintext highlighter-rouge">x</code>，满足<code class="language-plaintext highlighter-rouge">x</code>是<code class="language-plaintext highlighter-rouge">p</code>、<code class="language-plaintext highlighter-rouge">q</code>的祖先且<code class="language-plaintext highlighter-rouge">x</code>的深度尽可能大(一个节点也可以是它自己的祖先)。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>所有节点的值都是唯一的。</li> <li> <code class="language-plaintext highlighter-rouge">p</code>、<code class="language-plaintext highlighter-rouge">q</code>为不同节点且均存在于给定的二叉搜索树中。</li> </ul> <h4 id="solution-29">Solution</h4> <p>由于二叉搜索树是有序的，本题在代码层面要比<a href="/leetcode/2023-02-03-BinaryTree.html#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">二叉搜索树的最近公共祖先</a>简单一些。如果当前节点<code class="language-plaintext highlighter-rouge">root</code>是<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>的公共祖先，那么它一定位于区间<code class="language-plaintext highlighter-rouge">[p, q]</code>上。因此我们只需要从根节点开始进行遍历，当<code class="language-plaintext highlighter-rouge">root</code>位于区间<code class="language-plaintext highlighter-rouge">[p, q]</code>时直接返回即可。</p> <p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>迭代版本的代码可参考如下。</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">root</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">vmin</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
            <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">vmax</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h2 id="修改与构造-1">修改与构造</h2> <h3 id="701-二叉搜索树中的插入操作">701. 二叉搜索树中的插入操作</h3> <p>给定二叉搜索树(BST)的根节点<code class="language-plaintext highlighter-rouge">root</code>和要插入树中的值<code class="language-plaintext highlighter-rouge">value</code>，将值插入二叉搜索树。返回插入后二叉搜索树的根节点。输入数据<strong>保证</strong>新值和原始二叉搜索树中的任意节点值都不同。</p> <p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。你可以返回<strong>任意有效的结果</strong>。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/10/05/insertbst.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
</pre></td> </tr></tbody></table></code></pre></div></div> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/10/05/bst.jpg"> </div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [40,20,60,10,30,50,70], val = 25
输出：[40,20,60,10,30,50,70,null,null,25]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
输出：[4,2,7,1,3,5]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中的节点数将在<code class="language-plaintext highlighter-rouge">[0, 10⁴]</code>的范围内。</li> <li>-10⁸ &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 10⁸。</li> <li>所有值<code class="language-plaintext highlighter-rouge">Node.val</code>是<strong>独一无二</strong>的。</li> <li>-10⁸ &lt;= <code class="language-plaintext highlighter-rouge">val</code> &lt;= 10⁸。</li> <li>保证<code class="language-plaintext highlighter-rouge">val</code>在原始BST中不存在。</li> </ul> <h4 id="solution-30">Solution</h4> <p>本题的技巧在于把新节点作为叶节点插入到树本来的叶节点上，这样就只需要向下遍历二叉树即可。插入节点的条件如下：</p> <ul> <li>如果当前节点的左节点<code class="language-plaintext highlighter-rouge">root.left</code>为空且<code class="language-plaintext highlighter-rouge">root.val &gt; val</code>，则把<code class="language-plaintext highlighter-rouge">TreeNode(val)</code>插入到左节点中；</li> <li>如果当前节点的右节点<code class="language-plaintext highlighter-rouge">root.right</code>为空且<code class="language-plaintext highlighter-rouge">root.val &lt; val</code>，则把<code class="language-plaintext highlighter-rouge">TreeNode(val)</code>插入到右节点中；</li> <li>否则根据<code class="language-plaintext highlighter-rouge">root.val</code>与<code class="language-plaintext highlighter-rouge">val</code>的大小关系继续向下遍历。</li> </ul> <p>递归算法流程可以参考如下。</p> <div align="center"> <img src="https://search.pstatic.net/common?src=https://i.imgur.com/Bw4vpGs.gif"> </div> <p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">insertIntoBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">root</span>
        <span class="k">elif</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">root</span>
        
        <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">insertIntoBST</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">insertIntoBST</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">insertIntoBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span> <span class="n">insertIntoBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="n">insertIntoBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>迭代解法的思路与递归基本一致，代码可参考如下。</p> <p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">insertIntoBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">node</span> <span class="o">=</span> <span class="n">root</span>

        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
            <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
        
        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">insertIntoBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="450-删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点</h3> <p>给定一个二叉搜索树的根节点<code class="language-plaintext highlighter-rouge">root</code>和一个值<code class="language-plaintext highlighter-rouge">key</code>，删除二叉搜索树中的<code class="language-plaintext highlighter-rouge">key</code>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树(有可能被更新)的根节点的引用。</p> <p>一般来说，删除节点可分为两个步骤：</p> <ol> <li>首先找到需要删除的节点；</li> <li>如果找到了，删除它。</li> </ol> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> <td class="rouge-code"><pre>输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
</pre></td> </tr></tbody></table></code></pre></div></div> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg"> </div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例3：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入: root = [], key = 0
输出: []
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="solution-31">Solution</h4> <p>删除二叉搜索树中的节点比较复杂，这里我们首先明确函数的返回值为删除节点后该位置上的节点。根据当前节点值<code class="language-plaintext highlighter-rouge">root.val</code>我们可以分情况讨论：</p> <ul> <li>如果<code class="language-plaintext highlighter-rouge">root</code>为空说明<code class="language-plaintext highlighter-rouge">key</code>不在二叉树中，返回<code class="language-plaintext highlighter-rouge">None</code>；</li> <li>如果<code class="language-plaintext highlighter-rouge">key &lt; root.val</code>说明<code class="language-plaintext highlighter-rouge">key</code>可能位于左子树上，继续向<code class="language-plaintext highlighter-rouge">root.left</code>递归；</li> <li>如果<code class="language-plaintext highlighter-rouge">key &gt; root.val</code>说明<code class="language-plaintext highlighter-rouge">key</code>可能位于右子树上，继续向<code class="language-plaintext highlighter-rouge">root.right</code>递归；</li> <li>此时<code class="language-plaintext highlighter-rouge">root.val == key</code>说明<code class="language-plaintext highlighter-rouge">root</code>即为待删除节点，根据<code class="language-plaintext highlighter-rouge">root</code>是否是叶节点继续分情况讨论： <ul> <li>如果<code class="language-plaintext highlighter-rouge">root.left</code>为空且<code class="language-plaintext highlighter-rouge">root.right</code>非空，返回<code class="language-plaintext highlighter-rouge">root.right</code>作为新节点；</li> <li>如果<code class="language-plaintext highlighter-rouge">root.right</code>为空且<code class="language-plaintext highlighter-rouge">root.left</code>非空，返回<code class="language-plaintext highlighter-rouge">root.left</code>作为新节点；</li> <li>否则<code class="language-plaintext highlighter-rouge">root</code>不是叶节点，我们需要找到右子树的最左下节点<code class="language-plaintext highlighter-rouge">node</code>并把<code class="language-plaintext highlighter-rouge">root.left</code>连接到<code class="language-plaintext highlighter-rouge">node</code>上，最后用<code class="language-plaintext highlighter-rouge">root.right</code>来更新<code class="language-plaintext highlighter-rouge">root</code>。</li> </ul> </li> </ul> <p>整个删除节点的过程可以参考下图。</p> <div align="center"> <img src="https://search.pstatic.net/common?src=https://i.imgur.com/6OyQVgL.gif"> </div> <p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>
                <span class="c1">## leftmost node on the right child
</span>                <span class="k">while</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
                
                <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>
        
        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">delete</span> <span class="n">root</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                <span class="k">delete</span> <span class="n">root</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
                <span class="k">delete</span> <span class="n">root</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>

                <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
                
                <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                <span class="k">delete</span> <span class="n">cur</span><span class="p">;</span>

                <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">)</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
        <span class="k">else</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="669-修剪二叉搜索树">669. 修剪二叉搜索树</h3> <p>给你二叉搜索树的根节点<code class="language-plaintext highlighter-rouge">root</code>，同时给定最小边界<code class="language-plaintext highlighter-rouge">low</code>和最大边界<code class="language-plaintext highlighter-rouge">high</code>。通过修剪二叉搜索树，使得所有节点的值在<code class="language-plaintext highlighter-rouge">[low, high]</code>中。修剪树<strong>不应该</strong>改变保留在树中的元素的相对结构(即，如果没有被移除，原有的父代子代关系都应当保留)。可以证明，存在<strong>唯一的答案</strong>。</p> <p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/09/trim1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/09/trim2.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中的节点数将在<code class="language-plaintext highlighter-rouge">[1, 10⁴]</code>的范围内。</li> <li>0 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 10⁴。</li> <li>所树中每个节点的值都是<strong>唯一</strong>的。</li> <li>题目数据保证输入是一棵有效的二叉搜索树。</li> <li>0 &lt;= <code class="language-plaintext highlighter-rouge">low</code> &lt;= <code class="language-plaintext highlighter-rouge">high</code> &lt;= 10⁴。</li> </ul> <h4 id="solution-32">Solution</h4> <p>本题要利用二叉搜索树的性质进行求解。首先明确递归解法的返回值为当前树修剪后的根节点；当<code class="language-plaintext highlighter-rouge">root.val &lt; low</code>时说明<code class="language-plaintext highlighter-rouge">root</code>及其左子树<code class="language-plaintext highlighter-rouge">root.left</code>都在区间<code class="language-plaintext highlighter-rouge">[low, high]</code>之外，因此只需返回修剪后的右子树即可；类似地，当<code class="language-plaintext highlighter-rouge">root.val &lt; high</code>时只需返回修剪后的左子树；而当<code class="language-plaintext highlighter-rouge">root.val</code>在区间<code class="language-plaintext highlighter-rouge">[low, high]</code>中时则需要进一步递归处理左子树以及右子树。</p> <div align="center"> <img src="https://images.weserv.nl/?url=pic.leetcode-cn.com/1662768804-EhxyIe-1.png"> </div> <p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">trimBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">low</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">trimBST</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">trimBST</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">trimBST</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
            <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">trimBST</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">trimBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">)</span> <span class="k">return</span> <span class="n">trimBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">)</span> <span class="k">return</span> <span class="n">trimBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">=</span> <span class="n">trimBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">trimBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题的迭代解法要相对复杂一些，大体流程可以分为三步：</p> <ul> <li>寻找到位于区间<code class="language-plaintext highlighter-rouge">[low, high]</code>的节点作为<code class="language-plaintext highlighter-rouge">root</code>；</li> <li>处理左子树<code class="language-plaintext highlighter-rouge">root.left</code>使其都位于区间<code class="language-plaintext highlighter-rouge">[low, high]</code>内；</li> <li>处理右子树<code class="language-plaintext highlighter-rouge">root.right</code>使其都位于区间<code class="language-plaintext highlighter-rouge">[low, high]</code>内。</li> </ul> <p>在处理左右子树时需要结合二叉搜索树的性质：如果左节点的值小于<code class="language-plaintext highlighter-rouge">low</code>则整个左子树都小于<code class="language-plaintext highlighter-rouge">low</code>，此时需要把<code class="language-plaintext highlighter-rouge">node.left</code>设置为<code class="language-plaintext highlighter-rouge">node.left.right</code>并继续进行修剪；类似地，对于右节点则需要考虑右节点的值是否大于<code class="language-plaintext highlighter-rouge">high</code>，如果<code class="language-plaintext highlighter-rouge">node.right.val &gt; high</code>则需要向左移动<code class="language-plaintext highlighter-rouge">node.right = node.right.left</code>。</p> <p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">trimBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">low</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="c1">## find a valid root
</span>        <span class="k">while</span> <span class="n">root</span> <span class="ow">and</span> <span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">low</span> <span class="ow">or</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
        
        <span class="c1">## process left child
</span>        <span class="n">node</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">right</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>

        <span class="c1">## process right child
</span>        <span class="n">node</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">left</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
        
        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="108-将有序数组转换为二叉搜索树">108. 将有序数组转换为二叉搜索树</h3> <p>给你一个整数数组<code class="language-plaintext highlighter-rouge">nums</code>，其中元素已经按<strong>升序</strong>排列，请你将其转换为一棵<strong>高度平衡</strong>二叉搜索树。</p> <p><strong>高度平衡</strong>二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过1」的二叉树。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/18/btree1.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
</pre></td> </tr></tbody></table></code></pre></div></div> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/18/btree2.jpg"> </div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/18/btree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>1 &lt;= <code class="language-plaintext highlighter-rouge">nums.length</code> &lt;= 10⁴。</li> <li>-10⁴ &lt;= nums[i] &lt;= 10⁴。</li> <li> <code class="language-plaintext highlighter-rouge">nums</code>按<strong>严格递增</strong>顺序排列。</li> </ul> <h4 id="solution-33">Solution</h4> <p>本题的递归解法比较容易。我们只需要选择<code class="language-plaintext highlighter-rouge">nums</code>的中点作为<code class="language-plaintext highlighter-rouge">root</code>，然后分别对<code class="language-plaintext highlighter-rouge">nums</code>的左右部分递归构造构造左右子树即可。</p> <p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sortedArrayToBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">mid</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
        <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">sortedArrayToBST</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
        <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">sortedArrayToBST</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">sortedArrayToBST</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="1382-将二叉搜索树变平衡">1382. 将二叉搜索树变平衡</h3> <p>给你一棵二叉搜索树，请你返回一棵<strong>平衡后</strong>的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。</p> <p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过<code class="language-plaintext highlighter-rouge">1</code>，我们就称这棵二叉搜索树是<strong>平衡的</strong>。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入：root = [1,null,2,null,3,null,4,null,null]
输出：[2,1,3,null,null,null,4]
解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入: root = [2,1,3]
输出: [2,1,3]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树节点的数目在<code class="language-plaintext highlighter-rouge">[1, 10⁴]</code>范围内。</li> <li>1 &lt;= <code class="language-plaintext highlighter-rouge">Node.val</code> &lt;= 10⁵。</li> </ul> <h4 id="solution-34">Solution</h4> <p>本题解法可参考<a href="/leetcode/2023-02-03-BinaryTree.html#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">验证二叉搜索树</a>和<a href="/leetcode/2023-02-03-BinaryTree.html#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">将有序数组转换为二叉搜索树</a>，我们先利用<a href="/leetcode/2023-02-03-BinaryTree.html#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a>将二叉搜索树转换为有序数组<code class="language-plaintext highlighter-rouge">nums</code>，再从<code class="language-plaintext highlighter-rouge">nums</code>来构造平衡的二叉搜索树即可。</p> <p><a href="https://leetcode.cn/problems/balance-a-binary-search-tree/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td> <td class="rouge-code"><pre><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">balanceBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">res</span>   <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cur</span>   <span class="o">=</span> <span class="n">root</span>

            <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">left</span>
                
                <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span>
            
            <span class="k">return</span> <span class="n">res</span>
        
        <span class="k">def</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nums</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            
            <span class="n">mid</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">root</span><span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>

            <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
            <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="o">=</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>

            <span class="k">return</span> <span class="n">root</span>

        <span class="n">nums</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="k">return</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td> <td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">balanceBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nums</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stk</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cur</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]);</span>

        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h3 id="116-填充每个节点的下一个右侧节点指针">116. 填充每个节点的下一个右侧节点指针</h3> <p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> <td class="rouge-code"><pre>struct Node {
    int val;
    Node *left;
    Node *right;
    Node *next;
}
</pre></td> </tr></tbody></table></code></pre></div></div> <p>填充它的每个<code class="language-plaintext highlighter-rouge">next</code>指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将<code class="language-plaintext highlighter-rouge">next</code>指针设置为<code class="language-plaintext highlighter-rouge">NULL</code>。</p> <p>初始状态下，所有<code class="language-plaintext highlighter-rouge">next</code>指针都被设置为<code class="language-plaintext highlighter-rouge">NULL</code>。</p> <p><strong>示例1：</strong></p> <div align="center"> <img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2019/02/14/116_sample.png"> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre>输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>示例2：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre>输入：root = []
输出：[]
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong>提示：</strong></p> <ul> <li>树中节点的数量在<code class="language-plaintext highlighter-rouge">[0, 2¹² - 1]</code>范围内。</li> <li>-1000 &lt;= node.val &lt;= 1000。</li> </ul> <h4 id="solution-35">Solution</h4> <p>本题的基本解法是利用<a href="/leetcode/2023-02-03-BinaryTree.html#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</a>对每一层上的节点进行展开，然后令<code class="language-plaintext highlighter-rouge">next</code>指针指向同一层的下一个节点。</p> <div align="center"> <img src="https://images.weserv.nl/?url=pic.leetcode-cn.com/c657e60fe795868e754741d7019055879d3fd9a5152c965391312f00779d6121-2.jpg"> </div> <p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <p>python代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td> <td class="rouge-code"><pre><span class="sh">"""</span><span class="s">
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: </span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="s"> = None, right: </span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="s"> = None, next: </span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="s"> = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
</span><span class="sh">"""</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="sh">'</span><span class="s">Optional[Node]</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Optional[Node]</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td> <td class="rouge-code"><pre><span class="cm">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">connect</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="n">queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>  <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>

        <span class="p">}</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>本题的另一种解法是把每一层的节点看做是一个链表。对于同一层的节点，如果它们来自相同的父节点则可以通过父节点将它们连接起来。</p> <div align="center"> <img src="https://images.weserv.nl/?url=pic.leetcode-cn.com/b7317ab6466b08ae5c47abafd266f919b09a67d733a5a4d471c76da19737fb44-3.jpg"> </div> <p>如果它们来自不同的父节点，则可以通过前一个节点父节点的<code class="language-plaintext highlighter-rouge">next</code>指针来串联起来。</p> <div align="center"> <img src="https://images.weserv.nl/?url=pic.leetcode-cn.com/fff80ea5177cb58e6860d920d98d2df9a2d7bb1745015aff048dc4a2d1c6ad50-4.jpg"> </div> <p>这样我们只需要从第一层开始将下一层的节点连接起来即可。这种算法的空间复杂度为<code class="language-plaintext highlighter-rouge">O(1)</code>，其流程可以参考如下。</p> <div align="center"> <img src="https://search.pstatic.net/common?src=https://i.imgur.com/54tbhID.gif" width="70%"> </div> <p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" rel="external nofollow noopener" target="_blank">题目链接</a>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td> <td class="rouge-code"><pre><span class="sh">"""</span><span class="s">
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: </span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="s"> = None, right: </span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="s"> = None, next: </span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="s"> = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
</span><span class="sh">"""</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="sh">'</span><span class="s">Optional[Node]</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Optional[Node]</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">leftmost</span> <span class="o">=</span> <span class="n">root</span>
        
        <span class="k">while</span> <span class="n">leftmost</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">leftmost</span>

            <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
                <span class="n">head</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">right</span>
                
                <span class="k">if</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
                    <span class="n">head</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">left</span>
                
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
            
            <span class="n">leftmost</span> <span class="o">=</span> <span class="n">leftmost</span><span class="p">.</span><span class="n">left</span>
        
        <span class="k">return</span> <span class="n">root</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h2 id="reference">Reference</h2> <ul> <li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html" rel="external nofollow noopener" target="_blank">二叉树理论基础</a></li> <li><a href="https://www.bilibili.com/video/BV1Hy4y1t7ij/?vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">关于二叉树，你该了解这些！</a></li> <li><a href="https://www.bilibili.com/video/BV1Wh411S7xt/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：144.二叉树的前序遍历 145.二叉树的后序遍历 94.二叉树的中序遍历</a></li> <li><a href="https://www.bilibili.com/video/BV15f4y1W7i2/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">二叉树的非递归遍历</a></li> <li><a href="https://www.bilibili.com/video/BV1Zf4y1a77g/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">二叉树的非递归遍历-中序</a></li> <li><a href="https://www.bilibili.com/video/BV1sP4y1f7q7/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：6.翻转二叉树</a></li> <li><a href="https://www.bilibili.com/video/BV1ue4y1Y7Mf/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：101.对称二叉树</a></li> <li><a href="https://www.bilibili.com/video/BV1Gd4y1V75u/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：104.二叉树的最大深度</a></li> <li><a href="https://www.bilibili.com/video/BV1QD4y1B7e2/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：111.二叉树的最小深度</a></li> <li><a href="https://www.bilibili.com/video/BV1eW4y1B7pD/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：222.完全二叉树节点的数量</a></li> <li><a href="https://www.bilibili.com/video/BV1Ug411S7my/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：110.平衡二叉树</a></li> <li><a href="https://www.bilibili.com/video/BV1ZG411G7Dh/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：257.二叉树的所有路径</a></li> <li><a href="https://www.bilibili.com/video/BV1GY4y1K7z8/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：404.左叶子之和</a></li> <li><a href="https://www.bilibili.com/video/BV1424y1Z7pn/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：513.找二叉树左下角的值</a></li> <li><a href="https://www.bilibili.com/video/BV19t4y1L7CR/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：112.路径总和</a></li> <li><a href="https://www.bilibili.com/video/BV1vW4y1i7dn/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：106.从中序与后序遍历序列构造二叉树</a></li> <li><a href="https://www.bilibili.com/video/BV1MG411G7ox/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：654.最大二叉树</a></li> <li><a href="https://www.bilibili.com/video/BV1m14y1Y7JK/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：617.合并二叉树</a></li> <li><a href="https://www.bilibili.com/video/BV1wG411g7sF/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：700.二叉搜索树中的搜索</a></li> <li><a href="https://www.bilibili.com/video/BV18P411n7Q4/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：98.验证二叉搜索树</a></li> <li><a href="https://www.bilibili.com/video/BV1DD4y11779/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：530.二叉搜索树的最小绝对差</a></li> <li><a href="https://www.bilibili.com/video/BV1fD4y117gp/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：501.二叉搜索树中的众数</a></li> <li><a href="https://www.bilibili.com/video/BV1jd4y1B7E2/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：236.二叉树的最近公共祖先</a></li> <li><a href="https://www.bilibili.com/video/BV1Zt4y1F7ww/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：235.二叉搜索树的最近公共祖先</a></li> <li><a href="https://www.bilibili.com/video/BV1Et4y1c78Y/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：701.二叉搜索树中的插入操作</a></li> <li><a href="https://www.bilibili.com/video/BV1tP41177us/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：450.删除二叉搜索树中的节点</a></li> <li><a href="https://www.bilibili.com/video/BV17P41177ud/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：669.修剪二叉搜索树</a></li> <li><a href="https://www.bilibili.com/video/BV1uR4y1X7qL/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：108.将有序数组转换为二叉搜索树</a></li> <li><a href="https://www.bilibili.com/video/BV1d44y1f7wP/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826" rel="external nofollow noopener" target="_blank">LeetCode：538.把二叉搜索树转换为累加树</a></li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/distill/">a distill-style blog post</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/tables/">displaying beautiful tables with Bootstrap Tables</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2015/code/">a post with code</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2015/images/">a post with images</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/videos/">a post with videos</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Bo Peng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-post",title:"Post",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"A growing collection of your cool projects.",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-leetcode",title:"LeetCode",description:"",section:"Navigation",handler:()=>{window.location.href="/leetcode"}},{id:"nav-cv",title:"CV",description:"\u4e2a\u4eba\u7b80\u5386",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"dropdown-formatting-guide",title:"Formatting Guide",description:"",section:"Dropdown",handler:()=>{window.location.href=""}},{id:"post-google-gemini-updates-flash-1-5-gemma-2-and-project-astra",title:'Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra <svg width="1.2rem" height="1.2rem" top=".5rem" viewbox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg>',description:"We\u2019re sharing updates across our Gemini family of models and a glimpse of Project Astra, our vision for the future of AI assistants.",section:"Posts",handler:()=>{window.open("https://blog.google/technology/ai/google-gemini-update-flash-ai-assistant-io-2024/","_blank")}},{id:"post-a-post-with-tabs",title:"a post with tabs",description:"this is what included tabs in a post could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/tabs/"}},{id:"post-a-post-with-typograms",title:"a post with typograms",description:"this is what included typograms code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/typograms/"}},{id:"post-a-post-that-can-be-cited",title:"a post that can be cited",description:"this is what a post that can be cited looks like",section:"Posts",handler:()=>{window.location.href="/blog/2024/post-citation/"}},{id:"post-a-post-with-pseudo-code",title:"a post with pseudo code",description:"this is what included pseudo code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/pseudocode/"}},{id:"post-a-post-with-code-diff",title:"a post with code diff",description:"this is how you can display code diffs",section:"Posts",handler:()=>{window.location.href="/blog/2024/code-diff/"}},{id:"post-a-post-with-advanced-image-components",title:"a post with advanced image components",description:"this is what advanced image components could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/advanced-images/"}},{id:"post-a-post-with-vega-lite",title:"a post with vega lite",description:"this is what included vega lite code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/vega-lite/"}},{id:"post-a-post-with-geojson",title:"a post with geojson",description:"this is what included geojson code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/geojson-map/"}},{id:"post-a-post-with-echarts",title:"a post with echarts",description:"this is what included echarts code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/echarts/"}},{id:"post-a-post-with-chart-js",title:"a post with chart.js",description:"this is what included chart.js code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/chartjs/"}},{id:"post-a-post-with-tikzjax",title:"a post with TikZJax",description:"this is what included TikZ code could look like",section:"Posts",handler:()=>{window.location.href="/blog/2023/tikzjax/"}},{id:"post-a-post-with-bibliography",title:"a post with bibliography",description:"an example of a blog post with bibliography",section:"Posts",handler:()=>{window.location.href="/blog/2023/post-bibliography/"}},{id:"post-a-post-with-jupyter-notebook",title:"a post with jupyter notebook",description:"an example of a blog post with jupyter notebook",section:"Posts",handler:()=>{window.location.href="/blog/2023/jupyter-notebook/"}},{id:"post-a-post-with-custom-blockquotes",title:"a post with custom blockquotes",description:"an example of a blog post with custom blockquotes",section:"Posts",handler:()=>{window.location.href="/blog/2023/custom-blockquotes/"}},{id:"post-a-post-with-table-of-contents-on-a-sidebar",title:"a post with table of contents on a sidebar",description:"an example of a blog post with table of contents on a sidebar",section:"Posts",handler:()=>{window.location.href="/blog/2023/sidebar-table-of-contents/"}},{id:"post-a-post-with-audios",title:"a post with audios",description:"this is what included audios could look like",section:"Posts",handler:()=>{window.location.href="/blog/2023/audios/"}},{id:"post-a-post-with-videos",title:"a post with videos",description:"this is what included videos could look like",section:"Posts",handler:()=>{window.location.href="/blog/2023/videos/"}},{id:"post-displaying-beautiful-tables-with-bootstrap-tables",title:"displaying beautiful tables with Bootstrap Tables",description:"an example of how to use Bootstrap Tables",section:"Posts",handler:()=>{window.location.href="/blog/2023/tables/"}},{id:"post-a-post-with-table-of-contents",title:"a post with table of contents",description:"an example of a blog post with table of contents",section:"Posts",handler:()=>{window.location.href="/blog/2023/table-of-contents/"}},{id:"post-a-post-with-giscus-comments",title:"a post with giscus comments",description:"an example of a blog post with giscus comments",section:"Posts",handler:()=>{window.location.href="/blog/2022/giscus-comments/"}},{id:"post-displaying-external-posts-on-your-al-folio-blog",title:'Displaying External Posts on Your al-folio Blog <svg width="1.2rem" height="1.2rem" top=".5rem" viewbox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg>',description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@al-folio/displaying-external-posts-on-your-al-folio-blog-b60a1d241a0a?source=rss-17feae71c3c4------2","_blank")}},{id:"post-a-post-with-redirect",title:"a post with redirect",description:"you can also redirect to assets like pdf",section:"Posts",handler:()=>{window.location.href="/assets/pdf/example_pdf.pdf"}},{id:"post-a-post-with-diagrams",title:"a post with diagrams",description:"an example of a blog post with diagrams",section:"Posts",handler:()=>{window.location.href="/blog/2021/diagrams/"}},{id:"post-a-distill-style-blog-post",title:"a distill-style blog post",description:"an example of a distill-style blog post and main elements",section:"Posts",handler:()=>{window.location.href="/blog/2021/distill/"}},{id:"post-a-post-with-github-metadata",title:"a post with github metadata",description:"a quick run down on accessing github metadata.",section:"Posts",handler:()=>{window.location.href="/blog/2020/github-metadata/"}},{id:"post-a-post-with-twitter",title:"a post with twitter",description:"an example of a blog post with twitter",section:"Posts",handler:()=>{window.location.href="/blog/2020/twitter/"}},{id:"post-a-post-with-disqus-comments",title:"a post with disqus comments",description:"an example of a blog post with disqus comments",section:"Posts",handler:()=>{window.location.href="/blog/2015/disqus-comments/"}},{id:"post-a-post-with-math",title:"a post with math",description:"an example of a blog post with some math",section:"Posts",handler:()=>{window.location.href="/blog/2015/math/"}},{id:"post-a-post-with-code",title:"a post with code",description:"an example of a blog post with some code",section:"Posts",handler:()=>{window.location.href="/blog/2015/code/"}},{id:"post-a-post-with-images",title:"a post with images",description:"this is what included images could look like",section:"Posts",handler:()=>{window.location.href="/blog/2015/images/"}},{id:"post-a-post-with-formatting-and-links",title:"a post with formatting and links",description:"march & april, looking forward to summer",section:"Posts",handler:()=>{window.location.href="/blog/2015/formatting-and-links/"}},{id:"formatting-a-post-with-formatting-and-links",title:"a post with formatting and links",description:"march & april, looking forward to summer",section:"Formatting",handler:()=>{window.location.href="/formatting/formatting-and-links/"}},{id:"formatting-a-post-with-images",title:"a post with images",description:"this is what included images could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/images/"}},{id:"formatting-a-post-with-code",title:"a post with code",description:"an example of a blog post with some code",section:"Formatting",handler:()=>{window.location.href="/formatting/code/"}},{id:"formatting-a-post-with-math",title:"a post with math",description:"an example of a blog post with some math",section:"Formatting",handler:()=>{window.location.href="/formatting/math/"}},{id:"formatting-a-post-with-disqus-comments",title:"a post with disqus comments",description:"an example of a blog post with disqus comments",section:"Formatting",handler:()=>{window.location.href="/formatting/disqus-comments/"}},{id:"formatting-a-post-with-twitter",title:"a post with twitter",description:"an example of a blog post with twitter",section:"Formatting",handler:()=>{window.location.href="/formatting/twitter/"}},{id:"formatting-a-post-with-github-metadata",title:"a post with github metadata",description:"a quick run down on accessing github metadata.",section:"Formatting",handler:()=>{window.location.href="/formatting/github-metadata/"}},{id:"formatting-a-distill-style-blog-post",title:"a distill-style blog post",description:"an example of a distill-style blog post and main elements",section:"Formatting",handler:()=>{window.location.href="/formatting/distill/"}},{id:"formatting-a-post-with-diagrams",title:"a post with diagrams",description:"an example of a blog post with diagrams",section:"Formatting",handler:()=>{window.location.href="/formatting/diagrams/"}},{id:"formatting-a-post-with-redirect",title:"a post with redirect",description:"you can also redirect to assets like pdf",section:"Formatting",handler:()=>{window.location.href="/formatting/redirect/"}},{id:"formatting-a-post-with-giscus-comments",title:"a post with giscus comments",description:"an example of a blog post with giscus comments",section:"Formatting",handler:()=>{window.location.href="/formatting/giscus-comments/"}},{id:"formatting-a-post-with-table-of-contents",title:"a post with table of contents",description:"an example of a blog post with table of contents",section:"Formatting",handler:()=>{window.location.href="/formatting/table-of-contents/"}},{id:"formatting-displaying-beautiful-tables-with-bootstrap-tables",title:"displaying beautiful tables with Bootstrap Tables",description:"an example of how to use Bootstrap Tables",section:"Formatting",handler:()=>{window.location.href="/formatting/tables/"}},{id:"formatting-a-post-with-videos",title:"a post with videos",description:"this is what included videos could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/videos/"}},{id:"formatting-a-post-with-audios",title:"a post with audios",description:"this is what included audios could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/audios/"}},{id:"formatting-a-post-with-table-of-contents-on-a-sidebar",title:"a post with table of contents on a sidebar",description:"an example of a blog post with table of contents on a sidebar",section:"Formatting",handler:()=>{window.location.href="/formatting/sidebar-table-of-contents/"}},{id:"formatting-a-post-with-custom-blockquotes",title:"a post with custom blockquotes",description:"an example of a blog post with custom blockquotes",section:"Formatting",handler:()=>{window.location.href="/formatting/custom-blockquotes/"}},{id:"formatting-a-post-with-jupyter-notebook",title:"a post with jupyter notebook",description:"an example of a blog post with jupyter notebook",section:"Formatting",handler:()=>{window.location.href="/formatting/jupyter-notebook/"}},{id:"formatting-a-post-with-bibliography",title:"a post with bibliography",description:"an example of a blog post with bibliography",section:"Formatting",handler:()=>{window.location.href="/formatting/post-bibliography/"}},{id:"formatting-a-post-with-tikzjax",title:"a post with TikZJax",description:"this is what included TikZ code could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/tikzjax/"}},{id:"formatting-a-post-with-chart-js",title:"a post with chart.js",description:"this is what included chart.js code could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/chartjs/"}},{id:"formatting-a-post-with-echarts",title:"a post with echarts",description:"this is what included echarts code could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/echarts/"}},{id:"formatting-a-post-with-geojson",title:"a post with geojson",description:"this is what included geojson code could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/geojson-map/"}},{id:"formatting-a-post-with-vega-lite",title:"a post with vega lite",description:"this is what included vega lite code could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/vega-lite/"}},{id:"formatting-a-post-with-advanced-image-components",title:"a post with advanced image components",description:"this is what advanced image components could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/advanced-images/"}},{id:"formatting-a-post-with-code-diff",title:"a post with code diff",description:"this is how you can display code diffs",section:"Formatting",handler:()=>{window.location.href="/formatting/code-diff/"}},{id:"formatting-a-post-with-pseudo-code",title:"a post with pseudo code",description:"this is what included pseudo code could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/pseudocode/"}},{id:"formatting-a-post-that-can-be-cited",title:"a post that can be cited",description:"this is what a post that can be cited looks like",section:"Formatting",handler:()=>{window.location.href="/formatting/post-citation/"}},{id:"formatting-a-post-with-typograms",title:"a post with typograms",description:"this is what included typograms code could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/typograms/"}},{id:"formatting-a-post-with-tabs",title:"a post with tabs",description:"this is what included tabs in a post could look like",section:"Formatting",handler:()=>{window.location.href="/formatting/tabs/"}},{id:"leetcode-\u6570\u7ec4",title:"\u6570\u7ec4",description:"",section:"Leetcode",handler:()=>{window.location.href="/leetcode/Array/"}},{id:"leetcode-\u94fe\u8868",title:"\u94fe\u8868",description:"",section:"Leetcode",handler:()=>{window.location.href="/leetcode/LinkedList/"}},{id:"leetcode-\u54c8\u5e0c\u8868",title:"\u54c8\u5e0c\u8868",description:"",section:"Leetcode",handler:()=>{window.location.href="/leetcode/HashTable/"}},{id:"leetcode-\u5b57\u7b26\u4e32",title:"\u5b57\u7b26\u4e32",description:"",section:"Leetcode",handler:()=>{window.location.href="/leetcode/String/"}},{id:"leetcode-\u53cc\u6307\u9488",title:"\u53cc\u6307\u9488",description:"",section:"Leetcode",handler:()=>{window.location.href="/leetcode/TwoPointers/"}},{id:"leetcode-\u6808\u4e0e\u961f\u5217",title:"\u6808\u4e0e\u961f\u5217",description:"",section:"Leetcode",handler:()=>{window.location.href="/leetcode/StackQueue/"}},{id:"leetcode-\u4e8c\u53c9\u6811",title:"\u4e8c\u53c9\u6811",description:"",section:"Leetcode",handler:()=>{window.location.href="/leetcode/BinaryTree/"}},{id:"news-a-simple-inline-announcement",title:"A simple inline announcement.",description:"",section:"News"},{id:"news-a-long-announcement-with-details",title:"A long announcement with details",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_2/"}},{id:"news-a-simple-inline-announcement-with-markdown-emoji-sparkles-smile",title:'A simple inline announcement with Markdown emoji! <img class="emoji" title=":sparkles:" alt=":sparkles:" src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png" height="20" width="20"> <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20">',description:"",section:"News"},{id:"projects-project-1",title:"project 1",description:"with background image",section:"Projects",handler:()=>{window.location.href="/projects/1_project/"}},{id:"projects-project-2",title:"project 2",description:"a project with a background image and giscus comments",section:"Projects",handler:()=>{window.location.href="/projects/2_project/"}},{id:"projects-project-3-with-very-long-name",title:"project 3 with very long name",description:"a project that redirects to another website",section:"Projects",handler:()=>{window.location.href="/projects/3_project/"}},{id:"projects-project-4",title:"project 4",description:"another without an image",section:"Projects",handler:()=>{window.location.href="/projects/4_project/"}},{id:"projects-project-5",title:"project 5",description:"a project with a background image",section:"Projects",handler:()=>{window.location.href="/projects/5_project/"}},{id:"projects-project-6",title:"project 6",description:"a project with no image",section:"Projects",handler:()=>{window.location.href="/projects/6_project/"}},{id:"projects-project-7",title:"project 7",description:"with background image",section:"Projects",handler:()=>{window.location.href="/projects/7_project/"}},{id:"projects-project-8",title:"project 8",description:"an other project with a background image and giscus comments",section:"Projects",handler:()=>{window.location.href="/projects/8_project/"}},{id:"projects-project-9",title:"project 9",description:"another project with an image \ud83c\udf89",section:"Projects",handler:()=>{window.location.href="/projects/9_project/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%62%70%31%36%35%37@%6E%79%75.%65%64%75","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/peng00bo00","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/bo-peng-9600a4175","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>